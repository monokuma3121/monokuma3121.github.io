<!-- build time:Tue Jul 11 2023 20:16:36 GMT+0800 (香港标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>TS百练飞升 · Eucli</title><meta name="description" content="# 什么时候用 ts 写法？
类型能推导出来的时候不用写 ts，推导不出来的时候再写

类型断言
通过类型断言这种方式可以告诉编译器：“相信我，我知道自己在干什么”。类型断言好比其他语言里的类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响。TypeScript 会假设你已经进行了必须的检"><meta name="og:description" content="# 什么时候用 ts 写法？
类型能推导出来的时候不用写 ts，推导不出来的时候再写

类型断言
通过类型断言这种方式可以告诉编译器：“相信我，我知道自己在干什么”。类型断言好比其他语言里的类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响。TypeScript 会假设你已经进行了必须的检"><meta name="twitter:site" content="Eucli"><meta name="twitter:title" content="TS百练飞升"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div class="container" id="stage"><div class="row"><div class="col-sm-3 col-xs-12 side-container invisible" id="side-bar"><div class="vertical-text site-title"><h3 class="site-title-small" tabindex="-1"><a class="a-title" href="/">Typography</a></h3><h1 class="site-title-large" tabindex="-1"><a class="a-title" href="/">活版印字</a></h1></div><br class="visible-lg visible-md visible-sm"><div class="site-title-links" id="site-nav"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/categories">Categories</a></li><li><a href="/tags">Tags</a></li><li><a href="/categories/index.html">分类</a></li><li><a href="/css/comment.css"></a></li><li><a href="/css/mermaid.css"></a></li><li><a href="/css/app.css"></a></li><li><a href="/essay/index.html">即刻短文</a></li><li><a href="/link/index.html">友人帐</a></li><li><a href="/dailyPhoto/index.html">dailyPhoto</a></li><li><a href="/tags/index.html">标签</a></li><li class="soc"><a href="https://eucli.top/atom.xml" target="_blank" rel="noopener noreferrer" aria-label="RSS"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2023&nbsp;<a target="_blank" href="https://eucli.top" rel="noopener noreferrer">Eucli</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div class="col-sm-9 col-xs-12 main-container invisible" id="main-container"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>TS百练飞升</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2023-03-28</span><span class="meta-item"><i class="fa fa-folder"></i><span>&nbsp;</span><a class="a-tag" href="/categories/前端开发/" title="前端开发">前端开发</a><span>&nbsp;</span></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a class="a-tag" href="/tags/TypeScript/" title="TypeScript">TypeScript</a><span>&nbsp;</span></span></p><p class="post-abstract"></p><h2 id="什么时候用ts写法"><a class="markdownIt-Anchor" href="#什么时候用ts写法">#</a> 什么时候用 ts 写法？</h2><p>类型能推导出来的时候不用写 ts，推导不出来的时候再写</p><ul><li>类型断言<br>通过类型断言这种方式可以告诉编译器：“相信我，我知道自己在干什么”。类型断言好比其他语言里的类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响。TypeScript 会假设你已经进行了必须的检查。<br>断言类型有两种形式。其一是’‘尖括号’' 语法：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>:<span class="built_in">any</span> = <span class="string">&#x27;this is a string&#x27;</span>；</span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>:<span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).<span class="property">length</span>；</span><br></pre></td></tr></table></figure><p>另一个为 as 语法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>:<span class="built_in">any</span> = <span class="string">&#x27;this is a string&#x27;</span>；</span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>:<span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).<span class="property">length</span>；</span><br></pre></td></tr></table></figure><p>两种形式是等价的。至于使用哪个大多数情况是凭个人爱好；然而，当你在 TypeScript 里使用 JSX 时，只有 as 语法断言是被允许的。</p><p>——————————————————————————————————————————————————————————————————————————————————————————————————————————————</p><h1 id="认识-typescript"><a class="markdownIt-Anchor" href="#认识-typescript">#</a> 认识 TypeScript</h1><ul><li><p>JavaScript 的痛点：<br>JavaScript 在类型检测上依然是毫无进展，而，编程开发中我们有一个共识：错误出现的越早越好。能在写代码的时候发现错误，就不要在代码编译时再发现；能在代码编译期间发现错误，就不要在代码运行期间再发现（类型检测就可以很好的帮助我们做到这一点）；能在开发阶段发现错误，就不要在测试期间发现错误，能在测试期间发现错误，就不要在上线后发现错误</p></li><li><p>认识 TypeScript<br>TypeScript 是拥有类型的 JavaScript 超集。JavaScript 所拥有的特性，TypeScript 全部都是支持的，并且它紧随 ECMAScript 的标准，所以 ES6、ES7、ES8 等新语法标准，它都是支持的。<br>并且在语言层面上，不仅仅增加了类型约束，而且包括一些语法的扩展，比如枚举类型（Enum）、元组类型（Tuple）等<br>并且 TypeScript 最终会被编译成 JavaScript 代码，所以你并不需要担心它的兼容性问题，在编译时也不需要借助于 Babel 这样的工具</p></li></ul><h1 id="类型"><a class="markdownIt-Anchor" href="#类型">#</a> 类型</h1><h2 id="变量的声明"><a class="markdownIt-Anchor" href="#变量的声明">#</a> 变量的声明</h2><p>在 TypeScript 中定义变量需要指定 <strong>标识符 (变量)</strong> 的类型，声明的类型可以称之为 <code>类型注解</code><br><strong><code>var/let/const 标识符: 数据类型 = 赋值</code></strong><br>比如我们声明一个 message，完整的写法如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">message</span>: string = <span class="string">&quot;Hello World&quot;</span>;</span><br></pre></td></tr></table></figure><p>如果给 message 赋值其他类型的值，那么就会报错。<br>(注意：这里的 <code>string</code> 是小写的，和 <code>String</code> 是有区别的。 <code>string</code> 是 TypeScript 中定义的字符串类型， <code>String</code> 是 ECMAScript 中定义的一个类)</p><h2 id="声明变量的关键字"><a class="markdownIt-Anchor" href="#声明变量的关键字">#</a> 声明变量的关键字</h2><p>可以使用 <code>var</code> 、 <code>let</code> 、 <code>const</code> , 但不推荐使用 <code>var</code> 来声明变量，主要原因和 ES6 升级后 <code>let</code> 和 <code>var</code> 的区别是一样的， <code>var</code> 是没有块级作用域的，会引起很多的问题。</p><h2 id="变量的类型推导推断"><a class="markdownIt-Anchor" href="#变量的类型推导推断">#</a> 变量的类型推导（推断）</h2><p>在开发中，有时候为了方便起见我们并不会在声明每一个变量时都写上对应的数据类型，我们更希望可以通过 TypeScript 本身的特性帮助我们推断出对应的变量类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;Hello World&quot;</span>;</span><br></pre></td></tr></table></figure><p>如果这个时候再给 message 赋值 <code>123</code> , 就会报错，这是因为在一个变量第一次赋值时，会根据后面的赋值内容的类型，来推断出变量的类型。上面的 message 就是因为后面赋值的是一个 <code>string</code> 类型，所以 <code>message</code> 虽然没有明确的说明，但是依然是一个 <code>string</code> 类型。</p><h3 id="javascript-和-typescript-类型"><a class="markdownIt-Anchor" href="#javascript-和-typescript-类型">#</a> JavaScript 和 TypeScript 类型</h3><h4 id="javascript-类型-number类型"><a class="markdownIt-Anchor" href="#javascript-类型-number类型">#</a> JavaScript 类型 – <code>number</code> 类型</h4><p>数字类型是我们开发中经常使用的类型，TypeScript 和 JavaScript 一样，不区分整数类型（int）和浮点型（double），统一为 <code>number</code> 类型。</p><h4 id="javascript-类型-boolean类型"><a class="markdownIt-Anchor" href="#javascript-类型-boolean类型">#</a> JavaScript 类型 – <code>boolean</code> 类型</h4><p><code>boolean</code> 类型只有两个取值：true 和 false，非常简单</p><h4 id="javascript-类型-string类型"><a class="markdownIt-Anchor" href="#javascript-类型-string类型">#</a> JavaScript 类型 – <code>string</code> 类型</h4><p><code>string</code> 类型是字符串类型，可以使用单引号或者双引号表示。<br>同时也支持 ES6 的模板字符串 `` 来拼接变量和字符串</p><h4 id="javascript-类型-array类型"><a class="markdownIt-Anchor" href="#javascript-类型-array类型">#</a> JavaScript 类型 – <code>Array</code> 类型</h4><p>数组类型的定义有两种方式：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">names</span>: <span class="built_in">string</span>[] = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;cba&quot;</span>, <span class="string">&quot;cab&quot;</span>]; <span class="comment">//方式一，推荐</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">names2</span>: <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;cba&quot;</span>, <span class="string">&quot;nab&quot;</span>]; <span class="comment">//方式二，开发中不推荐使用，jsx有冲突，&lt;div&gt;&lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line">names.<span class="title function_">push</span>(<span class="string">&quot;why&quot;</span>);</span><br><span class="line">names2.<span class="title function_">push</span>(<span class="string">&quot;why&quot;</span>);</span><br></pre></td></tr></table></figure><p>第二种方式中的 <code>&lt;string&gt;</code> 是泛型， <code>const names2: Array&lt;string&gt; = [&quot;abc&quot;, &quot;cba&quot;, &quot;nab&quot;]</code> ; 其中：</p><ul><li><code>Array</code> ==&gt; 是一个 interface</li><li><code>&lt;string&gt;</code> ==&gt; 具体的某种类型：字符串类型</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names.<span class="title function_">push</span>(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><h4 id="javascript-类型-object类型"><a class="markdownIt-Anchor" href="#javascript-类型-object类型">#</a> JavaScript 类型 – <code>Object</code> 类型</h4><p><strong>(写对象类型不要写类型注解，让其类型推导即可)</strong></p><h4 id="javascript-类型-symbol-类型"><a class="markdownIt-Anchor" href="#javascript-类型-symbol-类型">#</a> JavaScript 类型 – Symbol 类型</h4><p>在 ES5 中，如果我们是不可以在对象中添加相同的属性名称的，比如下面的做法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">identity</span>: <span class="string">&quot;程序员&quot;</span>,</span><br><span class="line">  <span class="attr">identity</span>: <span class="string">&quot;老师&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通常我们的做法是定义两个不同的属性名字：比如 identity1 和 identity2<br>但是我们也可以通过 <code>symbol</code> 来定义相同的名称，因为 <code>Symbol</code> 函数返回的是不同的值：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">s1</span>: <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>(<span class="string">&quot;title&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="attr">s2</span>: <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>(<span class="string">&quot;title&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  [s1]: <span class="string">&quot;程序员&quot;</span>,</span><br><span class="line">  [s2]: <span class="string">&quot;老师&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="javascript-类型-null和undefined类型"><a class="markdownIt-Anchor" href="#javascript-类型-null和undefined类型">#</a> JavaScript 类型 – <code>null</code> 和 <code>undefined</code> 类型</h4><h4 id="typescript-类型-any类型"><a class="markdownIt-Anchor" href="#typescript-类型-any类型">#</a> TypeScript 类型 - <code>any</code> 类型</h4><p>在某些情况下，我们确实无法确定一个变量的类型，并且可能它会发生一些变化，这个时候我们可以使用 <code>any</code> 类型<br><code>any</code> 类型有点像一种讨巧的 TypeScript 手段：我们可以对 <code>any</code> 类型的变量进行任何的操作，包括获取不存在的属性、方法<br>如果对于某些情况的处理过于繁琐不希望添加规定的类型注解，或者在引入一些第三方库时，缺失了类型注解，这个时候我们可以使用 <code>any</code></p><h4 id="typescript-类型-unknown类型"><a class="markdownIt-Anchor" href="#typescript-类型-unknown类型">#</a> TypeScript 类型 - <code>unknown</code> 类型</h4><p><code>unknown</code> 是 TypeScript 中比较特殊的一种类型，它用于描述类型不确定的变量 (防止在别的地方乱用，区别于 <code>any</code> )<br>什么意思呢？我们来看下面的场景：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">result</span>: <span class="built_in">unknown</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">  result = <span class="title function_">foo</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  result = <span class="title function_">bar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> result === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">length</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><h4 id="typescript-类型-void类型"><a class="markdownIt-Anchor" href="#typescript-类型-void类型">#</a> TypeScript 类型 - <code>void</code> 类型</h4><p><code>void</code> 通常用来指定一个函数是没有返回值的，那么它的返回值就是 <code>void</code> 类型：<br>我们可以将 <code>null</code> 和 <code>undefined</code> 赋值给 <code>void</code> 类型，也就是函数可以返回 <code>null</code> 或者 <code>undefined</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num1 + num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数我们没有写任何类型，那么它默认返回值类型就是 <code>void</code> ，我们也可以显示的来指定返回值是 <code>void</code> :</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num1 + num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开发中一般是不写的</p><h4 id="typescript-类型-never类型"><a class="markdownIt-Anchor" href="#typescript-类型-never类型">#</a> TypeScript 类型 - <code>never</code> 类型</h4><p><code>never</code> 表示永远不会发生值的类型，比如一个函数：如果一个函数中是一个死循环或者抛出一个异常，那么这个函数会返回东西吗？不会，那么写 <code>void</code> 类型或者其他类型作为返回值类型都不合适，我们就可以使用 <code>never</code> 类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loopFun</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loopErr</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>never</code> 有什么样的应用场景呢？这里我们举一个例子，但是它用到了联合类型，后面我们会讲到：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleMessage</span>(<span class="params">message: <span class="built_in">number</span> | strintg</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="keyword">typeof</span> message) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;string&quot;</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;number&quot;</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">check</span>: <span class="built_in">never</span> = message;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="typescript-类型-tuple类型"><a class="markdownIt-Anchor" href="#typescript-类型-tuple类型">#</a> TypeScript 类型 - <code>tuple</code> 类型</h4><p><code>tuple</code> 是元组类型，很多语言中也有这种数据类型，比如 Python、Swift 等。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">tInfo</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="string">&quot;why&quot;</span>, <span class="number">18</span>, <span class="number">1.88</span>]; <span class="comment">//tuple的书写方式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">item1</span>: tInfo[<span class="number">0</span>]; <span class="comment">//why 并且知道类型是string类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">item1</span>: tInfo[<span class="number">1</span>]; <span class="comment">//18 并且知道类型是number类型</span></span><br></pre></td></tr></table></figure><p>那么 <code>tuple</code> 和数组有什么区别呢？</p><ol><li>首先，数组中通常建议存放相同类型的元素，不同类型的元素是不推荐放在数组中。（可以放在对象或者元组中）</li><li>其次，元组中每个元素都有自己特性的类型，根据索引值获取到的值可以确定对应的类型</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">info</span>: (<span class="built_in">string</span> | <span class="built_in">number</span>)[] = [<span class="string">&quot;why&quot;</span>, <span class="number">18</span>, <span class="number">1.88</span>]; <span class="comment">//数组书写方式</span></span><br><span class="line"><span class="keyword">const</span> item1 = info[<span class="number">0</span>]; <span class="comment">//不能确定类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">tInfo</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="string">&quot;why&quot;</span>, <span class="number">18</span>, <span class="number">1.88</span>]; <span class="comment">//tuple的书写方式</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">item2</span>: tInfo[<span class="number">0</span>]; <span class="comment">//一定是string类型</span></span><br></pre></td></tr></table></figure><p>Tuples 的应用场景：tuple 通常可以作为返回的值，在使用的时候会非常的方便</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> useState&lt;T&gt;(<span class="attr">state</span>: T): [T, [<span class="function">(<span class="params">newState:T</span>) =&gt;</span> <span class="built_in">void</span>] &#123;</span><br><span class="line">  <span class="keyword">let</span> currentState = state</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">changeState</span> = (<span class="params">newState:T</span>) =&gt; &#123;</span><br><span class="line">    currentState = newState</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [currentState,changeState]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [counter,setCounter] = <span class="title function_">useState</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h4 id="函数的参数类型与返回值类型"><a class="markdownIt-Anchor" href="#函数的参数类型与返回值类型">#</a> 函数的参数类型与返回值类型</h4><p>函数是 JavaScript 非常重要的组成部分，TypeScript 允许我们<strong>指定函数的参数和返回值的类型</strong>。</p><ul><li><p>参数的类型注解：声明函数时，可以在每个参数后添加类型注解，以声明函数接受的参数类型<br><img src="https://eucli-1314359160.cos.ap-beijing.myqcloud.com/test/9" alt=""> K4X1D1YO5 (SR] 5LBLCF%6.png)</p></li><li><p>返回值的类型注解，这个注解出现在函数列表的后面：</p></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和变量的类型注解一样，我们通常情况下不需要返回类型注解，因为 TypeScript 会根据 return 返回值推断函数的返回类型<br>某些第三方库处于方便理解，会明确指定返回类型，但是这个看个人喜好</p><h3 id="匿名函数的参数"><a class="markdownIt-Anchor" href="#匿名函数的参数">#</a> 匿名函数的参数</h3><p>匿名函数与函数声明会有一些不同：当一个函数出现在 TypeScript 可以确定该函数会被如何调用的地方时，该函数的参数会自动指定类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> names = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;cba&quot;</span>, <span class="string">&quot;nba&quot;</span>];</span><br><span class="line">names.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item.<span class="title function_">toUpperCase</span>());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们并没有指定 <code>item</code> 的类型，但是 <code>item</code> 是一个 string 类型：这是因为 TypeScript 会根据 <code>forEach</code> 函数的类型以及数组的类型推断出 <code>item</code> 的类型。这个过程称之为<strong>上下文类型（contextual typing）</strong>，因为函数执行的上下文可以帮助确定参数和返回值的类型</p><h3 id="对象类型"><a class="markdownIt-Anchor" href="#对象类型">#</a> 对象类型</h3><p>如果我们希望限定一个函数接受的参数是一个对象，我们可以使用对象类型:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printCoordinate</span>(<span class="params">point: &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;x坐标&quot;</span>, point.<span class="property">x</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;y坐标&quot;</span>, point.<span class="property">y</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printCoordinate</span>(&#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">30</span> &#125;);</span><br></pre></td></tr></table></figure><p>其中 <code>point</code> 是形参，而 <code>&#123; x: number; y: number &#125;</code> 是它的类型注解<br>我们使用了一个对象来作为类型，在对象我们可以添加属性，并且告知 TypeScript 该属性需要是什么类型；每个属性的类型部分也是可选的，如果不指定，那么就是 any 类型</p><h3 id="可选类型"><a class="markdownIt-Anchor" href="#可选类型">#</a> 可选类型</h3><p>对象类型也可以指定哪些属性是可选的，可以在属性的后面添加一个 <code>?：</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printCoordinate</span>(<span class="params">point: &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span>; z?: <span class="built_in">number</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;x坐标&quot;</span>, point.<span class="property">x</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;y坐标&quot;</span>, point.<span class="property">y</span>);</span><br><span class="line">  <span class="keyword">if</span> (point.<span class="property">z</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;z坐标&quot;</span>, point.<span class="property">z</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printCoordinate</span>(&#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">30</span> &#125;);</span><br><span class="line"><span class="title function_">printCoordinate</span>(&#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">30</span>, <span class="attr">z</span>: <span class="number">40</span> &#125;);</span><br></pre></td></tr></table></figure><ul><li>这个时候 x 和 y 依然是有类型的，它们的类型是： <code>number | undefined</code></li><li>可选类型需要在必传参数的后面</li></ul><h3 id="联合类型"><a class="markdownIt-Anchor" href="#联合类型">#</a> 联合类型</h3><p>TypeScript 的类型系统允许我们使用多种运算符，从现有类型中构建新类型<br>第一种组合类型的方法：<strong>联合类型（Union Type）</strong></p><ul><li>联合类型是由两个或者多个其他类型组成的类型</li><li>表示可以是这些类型中的任何一个值</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printId</span>(<span class="params">id: <span class="built_in">number</span> | <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;你的id是&quot;</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printId</span>(<span class="number">10</span>);</span><br><span class="line"><span class="title function_">printId</span>(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="使用联合类型"><a class="markdownIt-Anchor" href="#使用联合类型">#</a> 使用联合类型</h4><p>传入给一个联合类型的值是非常简单的，只要保证是联合类型中的某一个类型的值即可<br>但是我们拿到这个值之后，我们应该如何使用它呢？因为它可能是任何一种类型，比如我们拿到的值可能是 string 或者 number，我们就不能对其调用 string 上的一些方法</p><ul><li>我们需要使用<strong>缩小（narrow）联合</strong>，TypeScript 可以根据我们缩小的代码结构，推断出更加具体的类型；</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printId</span>(<span class="params">id: <span class="built_in">number</span> | <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> id === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;你的id是&quot;</span>, id.<span class="title function_">toUpperCase</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;你的id是&quot;</span>, id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型别名"><a class="markdownIt-Anchor" href="#类型别名">#</a> 类型别名</h3><p>在前面，我们通过在类型注解中编写 对象类型 和 联合类型，但是当我们想要多次在其他地方使用时，就要编写多次，这时候可以给对象类型起一个别名</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printPoint</span>(<span class="params">point: Point</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(point.<span class="property">x</span>, point.<span class="property">y</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printCoordinate</span>(&#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">30</span> &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">ID</span> = <span class="built_in">number</span> | <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printId</span>(<span class="params">id: ID</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;您的id：&quot;</span>, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型断言as"><a class="markdownIt-Anchor" href="#类型断言as">#</a> 类型断言 <code>as</code></h3><p>有时候 TypeScript 无法获取具体的类型信息，这个我们需要使用<strong>类型断言（Type Assertions）</strong></p><ul><li>我们通过 <code>document.getElementById</code> 去获得一个 dom，TypeScript 只知道该函数会返回 HTMLElement ，但并不知道它<br>具体的类型，这是就可以使用类型断言</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myEl = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;my_img&quot;</span>) <span class="keyword">as</span> <span class="title class_">HTMLImageElement</span>;</span><br><span class="line"></span><br><span class="line">myEl.<span class="property">src</span> = <span class="string">&quot;图片地址&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>注意：TypeScript 只允许类型断言转换为 更具体 或者 不太具体 的类型版本，此规则可防止不可能的强制转换：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;coderwhy&quot;</span> <span class="keyword">as</span> <span class="built_in">number</span>; <span class="comment">//报错</span></span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;coderwhy&quot;</span> <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> <span class="built_in">number</span>; <span class="comment">//这样就可以</span></span><br></pre></td></tr></table></figure><h3 id="非空类型断言"><a class="markdownIt-Anchor" href="#非空类型断言">#</a> 非空类型断言 <code>!</code></h3><p>当我们编写下面的代码时，在执行 ts 的编译阶段会报错，这是因为传入的 <code>message</code> 有可能是为 <code>undefined</code> 的，这个时候是不能执行方法的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printMessage</span>(<span class="params">message?: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">toUpperCase</span>()); <span class="comment">//error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printMessage</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><p>但是，我们确定传入的参数是有值的，这个时候我们可以使用非空类型断言 <code>!</code> ，表示可以<strong>确定某个标识符是有值的</strong>，跳过 ts 在编译阶段对它的检测</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printMessage</span>(<span class="params">message?: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message!.<span class="title function_">toUpperCase</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可选链"><a class="markdownIt-Anchor" href="#可选链">#</a> 可选链 <code>?.</code></h3><p>可选链事实上并不是 TypeScript 独有的特性，它是 ES11（ES2020）中增加的特性</p><ul><li>可选链使用可选链操作符 <code>?.</code></li><li>它的作用是当对象的属性不存在时，会短路，直接返回 undefined，如果存在，那么才会继续执行</li></ul><h2 id="和的作用"><a class="markdownIt-Anchor" href="#和的作用">#</a> <code>??</code> 和 <code>!!</code> 的作用</h2><ul><li><code>!!</code> 操作符：<br>将一个其他类型转换成 <code>boolean</code> 类型，类似于 <code>Boolean(变量)</code> 的方式</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> message = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> flag1 = <span class="title class_">Boolean</span>(message);</span><br><span class="line"><span class="keyword">let</span> flag2 = !!message;</span><br></pre></td></tr></table></figure><ul><li><code>??</code> 操作符：<br><strong>空值合并操作符</strong>（ <code>??</code> ）是一个逻辑操作符，当操作符的左侧是 null 或者 undefined 时，返回其右侧操作数，否则返回左侧操作数。（类似于三目运算符）</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> message = <span class="string">&quot;321&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> result = message ?? <span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure><p>一般结合可选链 <code>?.</code> 来使用:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="property">children</span>?.<span class="property">length</span> ?? &#123;&#125;</span><br><span class="line"><span class="comment">//&#123;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="字面量类型"><a class="markdownIt-Anchor" href="#字面量类型">#</a> 字面量类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">message</span>: <span class="string">&quot;hello&quot;</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">message = <span class="string">&quot;你好&quot;</span>;</span><br></pre></td></tr></table></figure><p>默认情况下这么做是没有太大的意义的，但是我们可以将多个类型联合在一起:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Alignment</span> = <span class="string">&quot;left&quot;</span> | <span class="string">&quot;right&quot;</span> | <span class="string">&quot;center&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeAlign</span>(<span class="params">align: Alignment</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;修改方向：&quot;</span>, align);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">changeAlign</span>();</span><br></pre></td></tr></table></figure><h3 id="类型缩小"><a class="markdownIt-Anchor" href="#类型缩小">#</a> 类型缩小</h3><ul><li>什么是类型缩小：<br>可以通过类似于 <code>typeof padding === &quot;number&quot;</code> 的判断语句，来改变 TypeScript 的执行路径，在给定的执行路径中，缩小比声明时更小的类型，这个过程称之为 类型缩小，而我们编写的 <code>typeof padding === &quot;number&quot;</code> 可以称之为 <strong>类型保护（type guards）</strong></li><li>常见的类型保护有如下几种：</li></ul><ol><li>typeof</li><li>平等缩小（比如 ===、!==）</li><li>instanceof</li><li>in</li></ol><h4 id="typeof"><a class="markdownIt-Anchor" href="#typeof">#</a> <code>typeof</code></h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">ID</span> = <span class="built_in">number</span> | <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printId</span>(<span class="params">id: ID</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> id === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(id.<span class="title function_">toUpperCase</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="平等缩小"><a class="markdownIt-Anchor" href="#平等缩小">#</a> 平等缩小</h4><p>我们可以使用 Switch 或者相等的一些运算符来表达相等性（比如 <code>===</code> , <code>!==</code> , <code>==</code> , <code>!=</code> ）：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Direction</span> = <span class="string">&quot;left&quot;</span> | <span class="string">&quot;right&quot;</span> | <span class="string">&quot;center&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">turnDirection</span>(<span class="params">direction: Direction</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;left&quot;</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;调用left方法&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;right&quot;</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;调用right方法&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;center&quot;</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;调用center方法&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;调用默认方法&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="instanceof"><a class="markdownIt-Anchor" href="#instanceof">#</a> <code>instanceof</code></h4><p>JavaScript 有一个运算符来检查一个值是否是另一个值的 “实例”：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printValue</span>(<span class="params">date: <span class="built_in">Date</span> | <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (date <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toLocaleString</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(date);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="in"><a class="markdownIt-Anchor" href="#in">#</a> <code>in</code></h4><p>Javascript 有一个运算符，用于确定对象是否具有带名称的属性： <code>in</code> 运算符。如果指定的属性在指定的对象或其原型链中，则 <code>in</code> 运算符返回 true；</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fish</span> = &#123; <span class="attr">swim</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Dog</span> = &#123; <span class="attr">run</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">move</span>(<span class="params">animal: Fish | Dog</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;swim&quot;</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">    animal.<span class="title function_">swim</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    animal.<span class="title function_">run</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="typescript-函数类型"><a class="markdownIt-Anchor" href="#typescript-函数类型">#</a> TypeScript 函数类型</h3><p>在 JavaScript 开发中，函数是重要的组成部分，并且函数可以作为一等公民（可以作为参数，也可以作为返回值进<br>行传递）。<br>TS 在使用函数的过程中，函数也可以有自己的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">CalcFunc</span> = <span class="function">(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calc</span>(<span class="params">fn: CalcFunc</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">calc</span>(sum);</span><br></pre></td></tr></table></figure><h4 id="typescript-函数类型解析"><a class="markdownIt-Anchor" href="#typescript-函数类型解析">#</a> TypeScript 函数类型解析</h4><p>在上面的语法中 <code>(num1: number, num2: number) =&gt; void</code> ，代表的就是一个函数类型：</p><ul><li>接收两个参数的函数：num1 和 num2，并且都是 number 类型；</li><li>并且这个函数是没有返回值的，所以是 void<br>在某些语言中，可能参数名称 num1 和 num2 是可以省略，但是 TypeScript 是不可以的。</li></ul><h4 id="默认参数"><a class="markdownIt-Anchor" href="#默认参数">#</a> 默认参数</h4><p>从 ES6 开始，JavaScript 是支持默认参数的，TypeScript 也是支持默认参数的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span> = <span class="number">6</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>这个时候 y 的类型其实是 undefined 和 number 类型的联合。</p><h4 id="剩余参数"><a class="markdownIt-Anchor" href="#剩余参数">#</a> 剩余参数</h4><p>从 ES6 开始，JavaScript 也支持剩余参数，剩余参数语法允许我们将一个不定数量的参数放到一个数组中</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">...nums: <span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    total += num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result1 = <span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result2 = <span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">400</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result2);</span><br></pre></td></tr></table></figure><h3 id="typescript-枚举类型"><a class="markdownIt-Anchor" href="#typescript-枚举类型">#</a> TypeScript 枚举类型</h3><p>枚举类型是为数不多的 TypeScript 特性有的特性之一：</p><ul><li>枚举其实就是将一组可能出现的值，一个个列举出来，定义在一个类型中，这个类型就是枚举类型</li><li>枚举允许开发者定义一组命名常量，常量可以是数字、字符串类型</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="variable constant_">LEFT</span>,</span><br><span class="line">  <span class="variable constant_">RIGHT</span>,</span><br><span class="line">  <span class="variable constant_">TOP</span>,</span><br><span class="line">  <span class="variable constant_">BOTTOM</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">turnDirection</span>(<span class="params">direction: Direction</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Direction</span>.<span class="property">LEFT</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;转向左边~&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Direction</span>.<span class="property">RIGHT</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;转向右边~&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Direction</span>.<span class="property">TOP</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;转向上边~&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Direction</span>.<span class="property">BOTTOM</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;转向下边~&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">myDirection</span>: <span class="built_in">never</span> = direction;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="枚举类型的值"><a class="markdownIt-Anchor" href="#枚举类型的值">#</a> 枚举类型的值</h4><p>枚举类型默认是有值的，比如上面的枚举，默认值是这样的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="variable constant_">LEFT</span> = <span class="number">0</span>,</span><br><span class="line">  <span class="variable constant_">RIGHT</span> = <span class="number">1</span>,</span><br><span class="line">  <span class="variable constant_">TOP</span> = <span class="number">2</span>,</span><br><span class="line">  <span class="variable constant_">BOTTOM</span> = <span class="number">3</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们也可以给枚举其他值，这个时候会从 100 进行递增：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="variable constant_">LEFT</span> = <span class="number">100</span>,</span><br><span class="line">  <span class="variable constant_">RIGHT</span>,</span><br><span class="line">  <span class="variable constant_">TOP</span>,</span><br><span class="line">  <span class="variable constant_">BOTTOM</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以给他们赋值其他的类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="variable constant_">LEFT</span>,</span><br><span class="line">  <span class="variable constant_">RIGHT</span>,</span><br><span class="line">  <span class="variable constant_">TOP</span> = <span class="string">&quot;TOP&quot;</span>,</span><br><span class="line">  <span class="variable constant_">BOTTOM</span> = <span class="string">&quot;BOTTOM&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ts-中的-this"><a class="markdownIt-Anchor" href="#ts-中的-this">#</a> TS 中的 this</h3><h4 id="可推导的-this-类型"><a class="markdownIt-Anchor" href="#可推导的-this-类型">#</a> 可推导的 this 类型</h4><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/hYm0JgBI25grNG_2sCRlTA">https://mp.weixin.qq.com/s/hYm0JgBI25grNG_2sCRlTA</a></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">info.<span class="title function_">sayHello</span>();</span><br></pre></td></tr></table></figure><p>上面的代码是可以正常运行的，TypeScript 认为函数 sayHello 有一个对应的 this 的外部对象 info，所以在使用时，就会把 this 当做该对象</p><h4 id="不确定的-this-类型"><a class="markdownIt-Anchor" href="#不确定的-this-类型">#</a> 不确定的 this 类型</h4><p>但是对于某些情况来说，我们并不知道 this 到底是什么:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  sayHello,</span><br><span class="line">&#125;;</span><br><span class="line">info.<span class="title function_">sayHello</span>();</span><br></pre></td></tr></table></figure><p>这段代码运行会报错的：这里对于 sayHello 的调用来说，我们虽然将其放到了 info 中，通过 info 去调用，this 依然是指向 info 对象的；但是对于 TypeScript 编译器来说，这个代码是非常不安全的，因为我们也有可能直接调用函数，或者通过别的对象来调用函数</p><h4 id="指定-this-的类型"><a class="markdownIt-Anchor" href="#指定-this-的类型">#</a> 指定 this 的类型</h4><p>这个时候，通常 TypeScript 会要求我们明确的指定 this 的类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NameType</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"><span class="variable language_">this</span>: NameType</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数的重载"><a class="markdownIt-Anchor" href="#函数的重载">#</a> 函数的重载</h1><p>在 TypeScript 中，如果我们编写了一个 add 函数，希望可以对字符串和数字类型进行相加，应该如何编写呢？<br>我们可能会这样来编写，但是其实是错误的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a1: <span class="built_in">number</span> | <span class="built_in">string</span>, a2: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="built_in">number</span> | <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a1 + a2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 TypeScript 中，我们可以去编写不同的重载签名（overload signatures）来表示函数可以以不同的方式进行调用<br>一般是编写两个或者以上的重载签名，再去编写一个通用的函数以及实现</p><h2 id="sum-函数的重载"><a class="markdownIt-Anchor" href="#sum-函数的重载">#</a> sum 函数的重载</h2><p>我们对 add 函数进行重构，在我们调用 add 的时候，它会根据我们传入的参数类型来决定执行函数体时，到底执行哪一个函数的重载签名</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a1: <span class="built_in">number</span>, a2: <span class="built_in">number</span></span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a1: <span class="built_in">string</span>, a2: <span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a1: <span class="built_in">any</span>, a2: <span class="built_in">any</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a1 + a2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>));</span><br></pre></td></tr></table></figure><h2 id="联合类型和重载"><a class="markdownIt-Anchor" href="#联合类型和重载">#</a> 联合类型和重载</h2><p>我们现在有一个需求：定义一个函数，可以传入字符串或者数组，获取它们的长度<br>这里有两种实现方案：</p><ol><li>使用联合类型来实现</li><li>实现函数重载来实现</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getLength</span>(<span class="params">a: <span class="built_in">string</span> | <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getLength</span>(<span class="params">a: <span class="built_in">string</span></span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getLength</span>(<span class="params">a: <span class="built_in">any</span>[]</span>): <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getLength</span>(<span class="params">a: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开发中一般使用联合类型</p><h1 id="类"><a class="markdownIt-Anchor" href="#类">#</a> 类</h1><h2 id="类的定义"><a class="markdownIt-Anchor" href="#类的定义">#</a> 类的定义</h2><p>定义一个<strong> Person</strong> 类：</p><ul><li>如果类型没有声明，那么它们默认是 any 的</li><li>也可以给属性设置初始化值</li><li>类可以有自己的构造函数 constructor，当我们通过 new 关键字创建一个实例时，构造函数会被调用</li><li>构造函数不需要返回任何值，默认返回当前创建出来的实例</li><li>如果我们在 strictPropertyInitialization 模式下确实不希望给属性初始化，可以使用 <code>name!: string</code> 语法</li><li>类中可以有自己的函数，定义的函数称之为方法</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  name!: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">running</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;running&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">eating</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;eating&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类的继承"><a class="markdownIt-Anchor" href="#类的继承">#</a> 类的继承</h2><p>面向对象的其中一大特性就是继承，继承不仅仅可以减少我们的代码量，也是多态的使用前提。<br>我们使用 extends 关键字来实现继承，子类中使用 super 来访问父类<br>在构造函数中，我们可以通过 super 来调用父类的构造方法，对父类中的属性进行初始化</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="attr">sno</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, sno: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name, age);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sno</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">studying</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;studying&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类的成员修饰符"><a class="markdownIt-Anchor" href="#类的成员修饰符">#</a> 类的成员修饰符</h2><p>在 TypeScript 中，类的属性和方法支持三种修饰符： <code>public</code> 、 <code>private</code> 、 <code>protected</code></p><ul><li><code>public</code> : 修饰的是在任何地方可见、公有的属性或方法，默认编写的属性就是 public 的</li><li><code>private</code> : 修饰的是仅在同一类中可见、私有的属性或方法</li><li><code>protected</code> : 修饰的是仅在类自身及子类中可见、受保护的属性或方法</li></ul><p><code>public</code> 是默认的修饰符，也是可以直接访问的，我们这里来演示一下 <code>protected</code> 和 <code>private</code> :</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">name</span>:<span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="title function_">running</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;running&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;why&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="只读属性-readonly"><a class="markdownIt-Anchor" href="#只读属性-readonly">#</a> 只读属性 readonly</h2><p>如果有一个属性我们不希望外界可以任意的修改，只希望确定值后直接使用，那么可以使用 <code>readonly</code> ：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;why&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="getterssetters"><a class="markdownIt-Anchor" href="#getterssetters">#</a> getters/setters</h2><p>在前面一些私有属性我们是不能直接访问的，或者某些属性我们想要监听它的 ** 获取 (getter)<strong> 和</strong>设置 (setter)** 的过程，这个时候我们可以使用存取器。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_name</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">newName</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = newName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>(<span class="params">newName</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;why&quot;</span>);</span><br><span class="line">p.<span class="property">name</span> = <span class="string">&quot;coderwhy&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>);</span><br></pre></td></tr></table></figure><h2 id="静态成员"><a class="markdownIt-Anchor" href="#静态成员">#</a> 静态成员</h2><p>前面我们在类中定义的成员和方法都属于对象级别的，在开发中，我们有时候也需要定义类级别的成员和方法：通过关键字 <code>static</code> 来定义:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="attr">time</span>: <span class="built_in">string</span> = <span class="string">&quot;20:00&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">attendClass</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;去上课&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Student</span>.<span class="property">time</span>);</span><br><span class="line"><span class="title class_">Student</span>.<span class="title function_">attendClass</span>();</span><br></pre></td></tr></table></figure><h2 id="抽象类-abstract"><a class="markdownIt-Anchor" href="#抽象类-abstract">#</a> 抽象类 abstract</h2><p>众<sub>所</sub>周<sub>知</sub>，继承是多态使用的前提：</p><ul><li>所以在定义很多通用的调用接口时，我们通常会让调用者传入父类，通过多态来实现更加灵活的调用方式。</li><li>但是，父类本身可能并不需要对某些方法进行具体的实现，所以父类中定义的方法，，我们可以定义为抽象方法。<br>什么是抽象方法？在 TypeScript 中没有具体实现的方法 (没有方法体)，就是抽象方法。</li><li>抽象方法，必须存在于抽象类中</li><li>抽象类是使用 abstract 声明的类</li></ul><p>抽象类有如下的特点：</p><ul><li>抽象类是不能被实例的话（也就是不能通过 new 创建）</li><li>抽象方法必须被子类实现，否则该类必须是一个抽象类</li></ul><h3 id="抽象类演练"><a class="markdownIt-Anchor" href="#抽象类演练">#</a> 抽象类演练</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">getArea</span>(): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">r</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">r: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">r</span> = r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getArea</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">r</span> * <span class="variable language_">this</span>.<span class="property">r</span> * <span class="number">3.14</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">width</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">height</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">width: <span class="built_in">number</span>, height: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">width</span> = width;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">height</span> = height;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getArea</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">width</span> * <span class="variable language_">this</span>.<span class="property">height</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle = <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">const</span> rectangle = <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calcArea</span>(<span class="params">shape: Shape</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(shape.<span class="title function_">getArea</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">calcArea</span>(circle);</span><br><span class="line"><span class="title function_">calcArea</span>(rectangle);</span><br></pre></td></tr></table></figure><h2 id="类的类型"><a class="markdownIt-Anchor" href="#类的类型">#</a> 类的类型</h2><p>类本身也是可以作为一种数据类型的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">running</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;running&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p1</span>: <span class="title class_">Person</span> = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;why&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="attr">p2</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;kobe&quot;</span>,</span><br><span class="line">  <span class="attr">running</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;running&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="接口的声明"><a class="markdownIt-Anchor" href="#接口的声明">#</a> 接口的声明</h1><p>在前面我们通过 type 可以用来声明一个对象类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对象的另外一种声明方式就是通过接口来声明：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span></span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口的可选属性"><a class="markdownIt-Anchor" href="#接口的可选属性">#</a> 接口的可选属性</h2><p>接口中我们也可以定义可选属性：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="built_in">string</span></span><br><span class="line">  age?:<span class="built_in">number</span></span><br><span class="line">  friend?:&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">person</span>:<span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&quot;why&quot;</span></span><br><span class="line">  <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">  <span class="attr">friend</span>:&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;kobe&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">friend</span>?.<span class="property">name</span>);</span><br></pre></td></tr></table></figure><h2 id="接口的只读属性"><a class="markdownIt-Anchor" href="#接口的只读属性">#</a> 接口的只读属性</h2><p>接口中也可以定义只读属性，这样就意味着我们再初始化之后，这个值是不可以被修改的:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>:<span class="built_in">string</span></span><br><span class="line">  age?:<span class="built_in">number</span></span><br><span class="line">  <span class="keyword">readonly</span> friend?:&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">person</span>:<span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&quot;why&quot;</span></span><br><span class="line">  <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">  <span class="attr">friend</span>:&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;kobe&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.<span class="property">name</span> = <span class="string">&quot;coderwhy&quot;</span>  <span class="comment">//不可以设置</span></span><br><span class="line">person.<span class="property">friend</span> = &#123;&#125;  <span class="comment">//不可以设置</span></span><br><span class="line"><span class="comment">//下面的代码是可以执行的</span></span><br><span class="line"><span class="keyword">if</span>(person.<span class="property">friend</span>) &#123;</span><br><span class="line">  person.<span class="property">friend</span>.<span class="property">name</span> = ‘<span class="number">123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口的索引类型"><a class="markdownIt-Anchor" href="#接口的索引类型">#</a> 接口的索引类型</h2><p>前面我们使用 interface 来定义对象类型，这个时候其中的属性名、类型、方法都是确定的，但是有时候我们会遇到类似下面的对象：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">FrontLanguage</span> = &#123;</span><br><span class="line">  [<span class="attr">index</span>:<span class="built_in">number</span>]:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">frontend</span>:<span class="title class_">FrontLanguage</span> = &#123;</span><br><span class="line">  <span class="number">1</span>:<span class="string">&quot;HTML&quot;</span>,</span><br><span class="line">  <span class="number">2</span>:<span class="string">&quot;CSS&quot;</span>,</span><br><span class="line">  <span class="number">3</span>:<span class="string">&quot;JavaScript&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">LanguageBirth</span> = &#123;</span><br><span class="line">  [<span class="attr">name</span>:<span class="built_in">string</span>]:<span class="built_in">string</span></span><br><span class="line">  <span class="title class_">Java</span>:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">lanuage</span>:<span class="title class_">LanguageBirth</span> = &#123;</span><br><span class="line">  <span class="string">&quot;Java&quot;</span>:<span class="number">1995</span>,</span><br><span class="line">  <span class="string">&quot;JavaScript&quot;</span>:<span class="number">1996</span>,</span><br><span class="line">  <span class="string">&quot;C&quot;</span>:<span class="number">1972</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口的函数类型"><a class="markdownIt-Anchor" href="#接口的函数类型">#</a> 接口的函数类型</h2><p>前面我们都是通过 interface 来定义对象中普通的属性和方法的，实际上它也可以用来定义函数类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">CalcFunc</span> = &#123;</span><br><span class="line">  (<span class="attr">num1</span>:<span class="built_in">number</span>,<span class="attr">num2</span>:<span class="built_in">number</span>):<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">add</span>:<span class="title class_">CalcFunc</span> = <span class="function">(<span class="params">num1,num2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">sub</span>:<span class="title class_">CalcFunc</span> = <span class="function">(<span class="params">num1,num2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 - num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，除非特别的情况，还是推荐大家使用类型别名来定义函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">CalcFunc</span> = <span class="function">(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure><h2 id="接口继承"><a class="markdownIt-Anchor" href="#接口继承">#</a> 接口继承</h2><p>接口和类一样是可以进行继承的，也是使用 extends 关键字，并且接口是支持多继承的（类不支持多继承）</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">eating</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">running</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>, <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">sno</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">stu</span>: <span class="title class_">Student</span> = &#123;</span><br><span class="line">  <span class="attr">sno</span>: <span class="number">110</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  <span class="attr">eating</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="attr">running</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="接口的实现"><a class="markdownIt-Anchor" href="#接口的实现">#</a> 接口的实现</h2><p>接口定义后，也是可以被类实现的：<br>如果被一个类实现，那么在之后需要传入接口的地方，都可以将这个类传入，这就是面向接口开发</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ISwim</span> &#123;</span><br><span class="line">  <span class="attr">swimming</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IRun</span> &#123;</span><br><span class="line">  <span class="attr">running</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">ISwim</span>, <span class="title class_">IRun</span> &#123;</span><br><span class="line">  <span class="title function_">swimming</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;swimming&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">running</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">swim</span>(<span class="params">swimmer: ISwim</span>) &#123;</span><br><span class="line">  swimmer.<span class="title function_">swimming</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="title function_">swim</span>(p);</span><br></pre></td></tr></table></figure><h2 id="交叉类型"><a class="markdownIt-Anchor" href="#交叉类型">#</a> 交叉类型</h2><p>前面我们学习了联合类型，表示多个类型中的一个即可：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Alignment</span> = <span class="string">&quot;left&quot;</span> | <span class="string">&quot;right&quot;</span> | <span class="string">&quot;center&quot;</span>;</span><br></pre></td></tr></table></figure><p>还有一种类型合并，称之为<strong>交叉类型</strong></p><ul><li>交叉类型表示需要满足多个条件</li><li>交叉类型使用 <code>&amp;</code> 符号<br>我们看下面的例子：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyType</span> = <span class="built_in">number</span> &amp; <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure><p>这表示的含义是是 number 和 string 要同时满足，但其实并没有一个值同时满足是一个 number 又是一个 string，所以 MyType 其实是一个 never 类型</p><h3 id="交叉类型的应用"><a class="markdownIt-Anchor" href="#交叉类型的应用">#</a> 交叉类型的应用</h3><p>在开发中，我们进行交叉时，通常是对对象类型进行交叉的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Colorful</span> &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IRun</span> &#123;</span><br><span class="line">  <span class="attr">running</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NewType</span> = <span class="title class_">Colorful</span> &amp; <span class="title class_">IRun</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: <span class="title class_">NewType</span> = &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">  <span class="attr">running</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="type和interface"><a class="markdownIt-Anchor" href="#type和interface">#</a> <code>type</code> 和 <code>interface</code></h1><ul><li>共同点：</li></ul><ol><li>都可以定义一个对象或函数</li><li>都允许继承（extends）</li></ol><ul><li>不同点：</li></ul><ol><li>type 可以声明基本类型、联合类型、交叉类型、元组，interface 不行</li><li>interface 可以合并重复声明，type 不行</li></ol><ul><li><p>小结<br>interface 是接口，用于描述一个对象。<br>type 是类型别名，用于给各种类型定义别名，让 TS 写起来更简洁、清晰。</p></li><li><p>平时开发中，如果要定义一个非对象类型，或者需要使用组合或者交叉类型的时候，用 type；如果要定义一个对象类型，或者要用类的 extends 或 implements 时，用 interface。<br>前端给后端返回数据，后端给前端返回的数据时，一般用 interface 对数据类型进行约束</p></li></ul><h3 id="字面量赋值"><a class="markdownIt-Anchor" href="#字面量赋值">#</a> 字面量赋值</h3><p>我们来看下面的代码：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="built_in">string</span></span><br><span class="line">  <span class="attr">eating</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>:<span class="title class_">IPerson</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&quot;why&quot;</span></span><br><span class="line">  <span class="attr">age</span>:<span class="number">18</span> <span class="comment">//报错：&#x27;age&#x27; does not exist</span></span><br><span class="line">  <span class="attr">eating</span>:<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为 TypeScript 在字面量直接赋值的过程中，为了进行类型推导会进行严格的类型限制。<br>但是之后如果我们是将一个 变量标识符 赋值给其他的变量时，会进行 freshness 擦除操作：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="built_in">string</span></span><br><span class="line">  <span class="attr">eating</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&quot;why&quot;</span></span><br><span class="line">  <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">  <span class="attr">eating</span>:<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>:<span class="title class_">IPerson</span> = obj</span><br></pre></td></tr></table></figure><h1 id="泛型"><a class="markdownIt-Anchor" href="#泛型">#</a> 泛型</h1><p>泛型 ==&gt; 形参</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数泛型</span></span><br><span class="line"><span class="keyword">function</span> fun&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">fun&lt;<span class="built_in">number</span>&gt;(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>这块代码中，可以将 <code>T</code> 看做形参， <code>string</code> 和 <code>number</code> 看做实参</p><hr><p>软件工程的主要目的是构建不仅仅明确和一致的 API，还要让你的代码具有很强的可重用性：比如我们可以通过函数来封装一些 API，通过传入不同的函数参数，让函数帮助我们完成不同的操作；但是对于参数的类型是否也可以参数化呢？</p><p>什么是类型的参数化？</p><ul><li>我们来提一个需求：封装一个函数，传入一个参数，并且返回这个参数</li><li>如果我们是 TypeScript 的思维方式，要考虑这个参数和返回值的类型需要一致：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">arg: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面的代码虽然实现了，但是不适用于其他类型，比如 string、boolean、Person 等类型：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">arg: <span class="built_in">any</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型就是类型变量，在 ts 中可以用来定义一些通用的类型，比如数组、函数、类等。泛型可以让你写出更灵活和可复用的代码，而不用担心类型错误<br>泛型适合一些需要根据不同的输入类型返回不同的输出类型的应用场景，在这些场景中，如果不用泛型，就需要为每种可能的输入类型写一个重载或者断言，这样会增加代码的复杂度和冗余。而用了泛型，就可以用一个类型参数来表示输入类型，并根据它推断出输出类型，这样就可以写出更简洁和通用的代码。</p><h2 id="泛型实现类型参数化"><a class="markdownIt-Anchor" href="#泛型实现类型参数化">#</a> 泛型实现类型参数化</h2><p>对于刚才的问题，虽然 any 是可以的，但是定义为 any 的时候，我们其实已经丢失了类型信息：</p><ul><li>比如我们传入的是一个 number，那么我们希望返回的可不是 any 类型，而是 number 类型；</li><li>所以，我们需要在函数中可以捕获到参数的类型是 number，并且同时使用它来作为返回值的类型；<br>我们需要在这里使用一种特性的变量 ——<strong> 类型变量（type variable）</strong>，它作用于类型，而不是值：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> foo&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们可以使用两种方式来调用它：</p><ol><li>通过 <code>&lt;类型&gt;</code> 的方式将类型传递给函数；</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">foo&lt;<span class="built_in">number</span>&gt;(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>通过类型推到，自动推到出我们传入变量的类型：在这里会推导出它们是 字面量类型的，因为字面量类型对于我们的函数也是适用的</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><h2 id="泛型的基本补充"><a class="markdownIt-Anchor" href="#泛型的基本补充">#</a> 泛型的基本补充</h2><p>当然我们也可以传入多个类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> foo&lt;T，E&gt;(<span class="attr">a1</span>: T,<span class="attr">a2</span>:E): <span class="title class_">Tyepe</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>平时在开发中我们可能会看到一些常用的名称：</p><ul><li><code>T</code> ：Type 的缩写，类型</li><li><code>K</code> 、 <code>V</code> ：key 和 value 的缩写，键值对</li><li><code>E</code> ：Element 的缩写，元素</li><li><code>O</code> ：Object 的缩写，对象</li></ul><p>这些名称都是标识符，可以写成任何的东西</p><h2 id="泛型接口"><a class="markdownIt-Anchor" href="#泛型接口">#</a> 泛型接口</h2><p>在定义接口的时候我们也可以使用泛型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title class_">IFoo</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">initialValue</span>:T,</span><br><span class="line">  <span class="attr">valueList</span>:T[],</span><br><span class="line">  <span class="attr">handleValue</span>:<span class="function">(<span class="params">value:T</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">foo</span>:<span class="title class_">IFoo</span>&lt;<span class="built_in">number</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">initialValue</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">valueList</span>:[<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  <span class="attr">handleValue</span>:<span class="keyword">function</span>(<span class="params">value:<span class="built_in">number</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型类"><a class="markdownIt-Anchor" href="#泛型类">#</a> 泛型类</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">x</span>:T,</span><br><span class="line">  <span class="attr">y</span>:T</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x:T,y:T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Point</span>&lt;<span class="built_in">number</span>&gt;(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="attr">p3</span>:<span class="title class_">Point</span>&lt;<span class="built_in">number</span>&gt; = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">10</span>,<span class="number">20</span>)</span><br></pre></td></tr></table></figure><h2 id="泛型约束"><a class="markdownIt-Anchor" href="#泛型约束">#</a> 泛型约束</h2><p>有时候我们希望传入的类型有某些共性，但是这些共性可能不是在同一种类型中：<br>比如 string 和 array 都是有 length 的，或者某些对象也是会有 length 属性的，那么只要是拥有 length 的属性都可以作为我们的参数类型，那么应该如何操作呢？</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ILength</span> &#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> getLength&lt;T <span class="keyword">extends</span> <span class="title class_">ILength</span>&gt;(<span class="attr">arg</span>: T) &#123;</span><br><span class="line">  <span class="keyword">return</span> args.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getLength</span>(<span class="string">&quot;abc&quot;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getLength</span>([<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;cba&quot;</span>]));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getLength</span>(&#123; <span class="attr">length</span>: <span class="number">100</span>, <span class="attr">name</span>: <span class="string">&quot;why&quot;</span> &#125;));</span><br></pre></td></tr></table></figure><h1 id="泛型-2"><a class="markdownIt-Anchor" href="#泛型-2">#</a> 泛型 2</h1><ul><li>泛型：可以理解为 【不确定】的【类型】</li><li>使用场景：复用性</li><li>好处：</li></ul><p>先看下面两段代码，分别是求数组和字符串的最小值：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getMinArray</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> min = arr[<span class="number">0</span>];</span><br><span class="line">  arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; min) &#123;</span><br><span class="line">      min = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getMinArray</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">36</span>]));</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getMinString</span>(<span class="params">arr: <span class="built_in">string</span>[]</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> min = arr[<span class="number">0</span>];</span><br><span class="line">  arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; min) &#123;</span><br><span class="line">      min = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getMinArray</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;cccc&quot;</span>, <span class="string">&quot;ddddd&quot;</span>]));</span><br></pre></td></tr></table></figure><p>以上两段代码都有一个共通的特性：内容相同，唯一不同的是参数类型。这时候就可以用</p><h2 id="泛型函数语法格式"><a class="markdownIt-Anchor" href="#泛型函数语法格式">#</a> 泛型函数语法格式：</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> 名称&lt;T&gt;(参数: T): T &#123;&#125;</span><br><span class="line">名称();</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用泛型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> getMin&lt;T&gt;(<span class="attr">arr</span>: T[]): T &#123;</span><br><span class="line">  <span class="keyword">let</span> min = arr[<span class="number">0</span>];</span><br><span class="line">  arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; min) &#123;</span><br><span class="line">      min = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getMin</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">36</span>]));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getMin</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;cccc&quot;</span>, <span class="string">&quot;ddddd&quot;</span>]));</span><br></pre></td></tr></table></figure><h3 id="泛型函数的类型和非泛型函数的类型有什么不同"><a class="markdownIt-Anchor" href="#泛型函数的类型和非泛型函数的类型有什么不同">#</a> 泛型函数的 “类型” 和非泛型函数的类型有什么不同？</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非泛型函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Fn1</span> = fn1; <span class="comment">// let Fn1:(arg:any) =&gt; any</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型函数</span></span><br><span class="line"><span class="keyword">function</span> fn2&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Fn2</span> = fn2; <span class="comment">//// let Fn2:&lt;T&gt;(arg:T) =&gt; T</span></span><br></pre></td></tr></table></figure><p>泛型函数类型前面有一个类型参数 (T)</p><h2 id="泛型接口-2"><a class="markdownIt-Anchor" href="#泛型接口-2">#</a> 泛型接口</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> fnInter&lt;T&gt; &#123;</span><br><span class="line">  (<span class="attr">arg</span>: T): T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型类-2"><a class="markdownIt-Anchor" href="#泛型类-2">#</a> 泛型类</h2><p>语法格式：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 名称&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> 名称&lt;类型&gt;();</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GetMin</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">arr</span>: T[] = [];</span><br><span class="line">  <span class="title function_">add</span>(<span class="params">el: T</span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">min</span>(): T &#123;</span><br><span class="line">    <span class="keyword">let</span> min = arr[<span class="number">0</span>];</span><br><span class="line">    arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (value &lt; min) &#123;</span><br><span class="line">        min = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">GetMin</span>&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">add</span>(<span class="number">1</span>);</span><br><span class="line">obj.<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">min</span>();</span><br></pre></td></tr></table></figure><h2 id="泛型约束-2"><a class="markdownIt-Anchor" href="#泛型约束-2">#</a> 泛型约束</h2><ul><li>泛型约束可以通过 <code>接口+extends</code> 来实现约束<br>为什么要有类型约束呢？我们先看下面一段代码：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> fn&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Fn</span> = <span class="title function_">fn</span>(<span class="string">&quot;abcd&quot;</span>);</span><br></pre></td></tr></table></figure><p>这个代码会报错，按理说传入的 <code>&quot;abcd&quot;</code> 是字符串，应该是具有 <code>length</code> 属性的，为什么还会报错呢？<br>这是因为这个函数不仅可以传入字符串，还能传入其他东西，如 <code>number</code> , <code>undefined</code> 等，这些是没有 <code>length</code> 属性的。<br>这时候我们就可以加入类型约束：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Len</span> &#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> fn&lt;T <span class="keyword">extends</span> <span class="title class_">Len</span>&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Fn</span> = <span class="title function_">fn</span>(<span class="string">&quot;abcd&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面多出的代码就是对 <code>T</code> 类型做了一个约束，即必须有 <code>length</code> 属性才可以</p><h1 id="作用域控制"><a class="markdownIt-Anchor" href="#作用域控制">#</a> 作用域控制</h1><p>TypeScript 支持两种方式来控制我们的作用域：</p><ol><li>模块化：每个文件可以是一个独立的模块，支持 ES Module，也支持 CommonJS；</li><li>命名空间：通过 <code>namespace</code> 来声明一个命名空间</li></ol><h2 id="模块化开发"><a class="markdownIt-Anchor" href="#模块化开发">#</a> 模块化开发</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">sub</span>(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命名空间-namespace"><a class="markdownIt-Anchor" href="#命名空间-namespace">#</a> 命名空间 namespace</h2><p>命名空间在 TypeScript 早期时，称之为内部模块，主要目的是将一个模块内部再进行作用域的划分，防止一些命名冲突的问题。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> <span class="title class_">Time</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">format</span>(<span class="params">time: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;2022-02-22&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> <span class="title class_">Price</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">format</span>(<span class="params">price: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;222.22&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类型的查找"><a class="markdownIt-Anchor" href="#类型的查找">#</a> 类型的查找</h1><p>之前我们所有的 typescript 中的类型，几乎都是我们自己编写的，但是我们也有用到一些其他的类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> imageEl = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;image&quot;</span>) <span class="keyword">as</span> <span class="title class_">HTMLImageElement</span>;</span><br></pre></td></tr></table></figure><p>大家是否会奇怪，我们的 HTMLImageElement 类型来自哪里呢？甚至是 document 为什么可以有 getElementById 的方法呢？其实这里就涉及到 typescript 对类型的管理和查找规则了。</p><ul><li><p>这里先介绍另外的一种 typescript 文件： <code>.d.ts</code> 文件<br>之前编写的 typescript 文件都是 .ts 文件，这些文件最终会输出 .js 文件，还有另外一种文件 <code>.d.ts</code> 文件，它是用来做类型的声明 ( <code>declare</code> )。 它仅仅用来做类型检测，告知 typescript 我们有哪些类型</p></li><li><p>那么 typescript 会在哪里查找我们的类型声明呢？</p></li></ul><ol><li>内置类型声明</li><li>外部定义类型声明</li><li>自己定义类型声明</li></ol><h2 id="内置类型声明"><a class="markdownIt-Anchor" href="#内置类型声明">#</a> 内置类型声明</h2><p>内置类型声明是 typescript 自带的、帮助我们内置了 JavaScript 运行时的一些标准化 API 的声明文件，包括比如 Math、Date 等内置类型，也包括 DOM API，比如 Window、Document 等。内置类型声明通常在我们安装 typescript 的环境中会带有的</p><h2 id="外部定义类型声明"><a class="markdownIt-Anchor" href="#外部定义类型声明">#</a> 外部定义类型声明</h2><p>外部类型声明通常是我们使用一些库（比如第三方库）时，需要的一些类型声明。这些库通常有两种类型声明方式：</p><ol><li>在自己库中进行类型声明（编写.d.ts 文件），比如 axios</li><li>通过社区的一个公有库 DefinitelyTyped 存放类型声明文件</li></ol><h2 id="自己定义类型声明"><a class="markdownIt-Anchor" href="#自己定义类型声明">#</a> 自己定义类型声明</h2><p>什么情况下需要自己来定义声明文件呢？</p><ol><li>情况一：我们使用的第三方库是一个纯的 JavaScript 库，没有对应的声明文件；比如 lodash</li><li>情况二：我们给自己的代码中声明一些类型，方便在其他地方直接进行使用；</li></ol><h3 id="声明变量-函数-类"><a class="markdownIt-Anchor" href="#声明变量-函数-类">#</a> 声明变量 - 函数 - 类</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wName = <span class="string">&quot;coderwhy&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> wAge = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">let</span> wHeight = <span class="number">1.88</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">wFoo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;wFoo&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">wBar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;wBar&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">wName</span>: <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">wAge</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">wHeight</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">wFoo</span>(<span class="params"></span>): <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">wBar</span>(<span class="params"></span>): <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明模块"><a class="markdownIt-Anchor" href="#声明模块">#</a> 声明模块</h3><p>我们也可以声明模块，比如 lodash 模块默认不能使用的情况，可以自己来声明这个模块：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;lodash&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">join</span>(<span class="params">args: <span class="built_in">any</span>[]</span>): <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>声明模块的语法: <code>declare module '模块名' &#123;&#125;</code><br>在声明模块的内部，我们可以通过 export 导出对应库的类、函数等</li></ul><h3 id="declare-文件"><a class="markdownIt-Anchor" href="#declare-文件">#</a> declare 文件</h3><p>在某些情况下，我们也可以声明文件：</p><ul><li>比如在开发 vue 的过程中，默认是不识别我们的.vue 文件的，那么我们就需要对其进行文件的声明</li><li>比如在开发中我们使用了 jpg 这类图片文件，默认 typescript 也是不支持的，也需要对其进行声明</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> modele <span class="string">&#x27;*.vue&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123;<span class="title class_">DefineComponent</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">component</span>:<span class="title class_">DefineComponent</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> component</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> modele <span class="string">&#x27;*.jpg&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">src</span>:<span class="built_in">string</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> src</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="declare-命名空间"><a class="markdownIt-Anchor" href="#declare-命名空间">#</a> declare 命名空间</h3><p>比如我们在 index.html 中直接引入了 jQuery, 我们可以进行命名空间的声明：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> $ &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">settings: <span class="built_in">any</span></span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 main.ts 中就可以使用了：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">success</span>:<span class="function">(<span class="params">res:<span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="装饰器"><a class="markdownIt-Anchor" href="#装饰器">#</a> 装饰器</h1><ul><li>如果要使用装饰器，必须在 tsconfig.json 中进行配置： <code>&quot;experimentalDecorators&quot;:true</code></li></ul><h2><a class="markdownIt-Anchor" href="#">#</a></h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun1</span>(<span class="params">target:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">  target.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">userName</span> = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@fun1</span>  <span class="comment">// 等同于fun1(Person1)</span></span><br><span class="line">clsaa = <span class="title class_">Person1</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person1</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">userName</span>)</span><br></pre></td></tr></table></figure><p></p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></span><span class="soc"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></span><span class="soc"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=https://eucli.top/2023/03/28/TS百练飞升/%20Eucli%20TS百练飞升"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/2023/04/04/%E4%BC%98%E9%9B%85%E7%9A%84%E5%8D%95%E8%A1%8C%E4%BB%A3%E7%A0%81/" title="优雅的单行代码"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: 优雅的单行代码</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/2023/03/24/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%EF%BC%9AVite%20+%20Vue3%20+%20Typescript%20+%20Pinia%20+%20Vueuse%E9%A1%B9%E7%9B%AE/" title="快速搭建：Vite + Vue3 + Typescript + Pinia + Vueuse项目">Next post: 快速搭建：Vite + Vue3 + Typescript + Pinia + Vueuse项目&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2023&nbsp;<a target="_blank" href="https://eucli.top" rel="noopener noreferrer">Eucli</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html><!-- rebuild by hrmmi -->