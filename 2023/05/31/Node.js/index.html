<!-- build time:Tue Jul 11 2023 18:08:14 GMT+0800 (香港标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="theme-color" content="#202020"><meta http-equiv="x-ua-compatible" content="ie=edge"><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><meta name="keywords" content="Node.js,"><meta name="description" content="Node.js"><link rel="icon" type="image/x-icon" href="/logo.png"><title>Node.js [ Eucli ]</title><link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" href="/css/xoxo.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="nav-container"><nav class="home-menu pure-menu pure-menu-horizontal"><a class="pure-menu-heading" href="/"><img class="avatar" src="https://eucli.top/images/logo.png"> <span class="title">Eucli</span></a><ul class="pure-menu-list clearfix"><li class="pure-menu-item"><a href="/" class="pure-menu-link">首页</a></li><li class="pure-menu-item"><a href="/archives" class="pure-menu-link">归档</a></li><li class="pure-menu-item"><a href="/tags" class="pure-menu-link">标签</a></li><li class="pure-menu-item"><a href="/search" class="pure-menu-link">搜索</a></li><li class="pure-menu-item"><a target="_blank" rel="noopener" href="https://0xff000000.com" class="pure-menu-link">关于</a></li><li class="pure-menu-item"><a href="/atom.xml" class="pure-menu-link">订阅</a></li></ul></nav></div><div class="container" id="content-outer"><div class="inner" id="content-inner"><div class="post-container"><article class="post" id="post"><header class="post-header text-center"><h1 class="title">Node.js</h1><span><time class="time" datetime="2023-05-31T10:20:34.000Z">2023-05-31 </time></span><span class="slash">/</span> <span class="post-meta"><span class="post-tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node-js/" rel="tag">Node.js</a></li></ul></span></span><span class="slash">/</span> <span class="read"><span id="busuanzi_value_page_pv"></span> 点击</span></header><div class="post-content"><blockquote><p>NodeJS 二三事</p></blockquote><ul><li>浏览器中的 javascript<br>![](<a target="_blank" rel="noopener" href="https://eucli-1314359160.cos.ap-beijing.myqcloud.com/test/6T_">https://eucli-1314359160.cos.ap-beijing.myqcloud.com/test/6T_</a>{RAS8(KQ3SRX[SK8WDYT.png)</li><li>Node.js 中的 javascript<br><img src="https://eucli-1314359160.cos.ap-beijing.myqcloud.com/test/@GYE0D_MX7EBAJO@H%5DOJ6@5.png" alt=""><br>nodejs 中不能使用 BOM 和 DOM 的 API</li><li>nodejs 顶级对象： <code>global</code></li></ul><blockquote><p>计算机基础快看</p></blockquote><ul><li>计算机主板主要由 CPU、内存（运算快，断电数据丢失），硬盘（运算慢，断电数据不丢失）组成。</li><li>操作系统（windows、linux、macos）也是一种应用程序，用来管理和调度硬件资源。<br>“装系统” 就是把操作系统这个应用程序装到硬盘的过程<br>！[](<a target="_blank" rel="noopener" href="https://eucli-1314359160.cos.ap-beijing.myqcloud.com/test/CMYQUPFP(SH3M4X4KAODUGX.png)">https://eucli-1314359160.cos.ap-beijing.myqcloud.com/test/CMYQUPFP(SH3M4X4KAODUGX.png)</a><br>程序一般保存在硬盘中，软件安装的过程就是将程序写入硬盘的过程<br>程序在运行时会加载进入内存，然后由 cpu 读取并执行程序</li><li>进程和线程<br>进程：进行（运行）中的程序。windows 可以通过任务管理器查看进程<br>线程：线程是一个进程中执行的一个执行流。一个线程是属于某个进程的（工厂和工人的关系）<br><img src="https://eucli-1314359160.cos.ap-beijing.myqcloud.com/test/%5BMS$WLCI3Q%7BP~C@N_%25WHMUA.png" alt=""></li></ul><h1 id="buffer缓冲器"><a class="markdownIt-Anchor" href="#buffer缓冲器">#</a> Buffer（缓冲器）</h1><h2 id="概念"><a class="markdownIt-Anchor" href="#概念">#</a> 概念</h2><p>Buffer 是一个类似于数组的 <code>对象</code> ，用于表示固定长度的字节序列</p><p>Buffer 本质是一段内存空间，专门用来处理 <code>二进制数据</code> 。</p><p><img src="../image/buffer.png" alt="image-20230320173023659"></p><h2 id="特点"><a class="markdownIt-Anchor" href="#特点">#</a> 特点</h2><ol><li>Buffer 大小固定且无法调整</li><li>Buffer 性能较好，可以直接对计算机内存进行操作</li><li>每个元素的大小为 1 字节（byte）</li></ol><p><img src="../image/buffer2.png" alt="image-20230320173043532"></p><h2 id="使用"><a class="markdownIt-Anchor" href="#使用">#</a> 使用</h2><h3 id="创建-buffer"><a class="markdownIt-Anchor" href="#创建-buffer">#</a> 创建 Buffer</h3><p>Node.js 中创建 Buffer 的方式主要如下几种：</p><ol><li><p><code>Buffer.alloc</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建了一个长度为 10 字节的 Buffer，相当于申请了 10 字节的内存空间，每个字节的值为 0</span></span><br><span class="line"><span class="keyword">let</span> buf_1 = <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">10</span>); <span class="comment">//=&gt;结果为&lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>Buffer.allocUnsafe</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建了一个长度为 10 字节的 Buffer，buffer 中可能存在旧数据，可能会影响执行结果，所以叫 unsafe ，但是效率比 alloc 高</span></span><br><span class="line"><span class="keyword">let</span> buf_2 = <span class="title class_">Buffer</span>.<span class="title function_">allocUnsafe</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>Buffer.from</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过字符串创建 Buffer</span></span><br><span class="line"><span class="keyword">let</span> buf_3 = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">// 通过数组创建 Buffer</span></span><br><span class="line"><span class="keyword">let</span> buf_4 = <span class="title class_">Buffer</span>.<span class="title function_">from</span>([<span class="number">105</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">118</span>, <span class="number">101</span>, <span class="number">121</span>, <span class="number">111</span>, <span class="number">117</span>]);</span><br></pre></td></tr></table></figure></li></ol><h3 id="buffer-与字符串的转化"><a class="markdownIt-Anchor" href="#buffer-与字符串的转化">#</a> Buffer 与字符串的转化</h3><blockquote><p>我们可以借助 <code>toString</code> 方法将 Buffer 转为字符串</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buf_4 = <span class="title class_">Buffer</span>.<span class="title function_">from</span>([<span class="number">105</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">118</span>, <span class="number">101</span>, <span class="number">121</span>, <span class="number">111</span>, <span class="number">117</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf_4.<span class="title function_">toString</span>()); <span class="comment">//=&gt;iloveyou</span></span><br></pre></td></tr></table></figure><p><strong>注意:</strong> <code>toString</code> 默认是按照 <code>utf-8</code> 编码方式进行转换的</p><h3 id="buffer-的读写"><a class="markdownIt-Anchor" href="#buffer-的读写">#</a> Buffer 的读写</h3><blockquote><p>Buffer 可以直接通过 <code>[]</code> 的方式对数据进行处理。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buf_3 = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf_3[<span class="number">1</span>]); <span class="comment">//=&gt;101</span></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">buf_3[<span class="number">1</span>] = <span class="number">97</span>;</span><br><span class="line"><span class="comment">//查看字符串结果</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf_3.<span class="title function_">toString</span>()); <span class="comment">//=&gt;hallo</span></span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>溢出：如果修改的数值超过 <code>255</code> ，则<span style="color:red">超过</span> <code>8</code> 位数据会被舍弃</li><li>中文：一个 <code>utf-8</code> 的字符 <span style="color:red">一般</span> 占 3 个字节</li></ol><h1 id="fs-模块fs-api"><a class="markdownIt-Anchor" href="#fs-模块fs-api">#</a> fs 模块（fs API）</h1><blockquote><p>fs 全称为 <code>file system</code> ，称之为 <code>文件系统</code> ，是 Node.js 中的 <code>内置模块</code> ，可以对计算机中的磁盘进行操作。</p></blockquote><p>本章节会介绍如下几个操作：</p><ol><li><p>文件写入</p></li><li><p>文件读取</p></li><li><p>文件移动与重命名</p></li><li><p>文件删除</p></li><li><p>文件夹操作</p></li><li><p>查看资源状态</p></li></ol><h2 id="文件写入"><a class="markdownIt-Anchor" href="#文件写入">#</a> 文件写入</h2><blockquote><p>文件写入就是将 <span style="color:red">数据</span> 保存到 <span style="color:red">文件</span> 中，我们可以使用如下几个方法来实现该效果</p></blockquote><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>writeFile</td><td>异步写入</td></tr><tr><td>writeFileSync</td><td>同步写入</td></tr><tr><td>appendFile / appendFileSync</td><td>追加写入</td></tr><tr><td>createWriteStream</td><td>流式写入</td></tr></tbody></table><h3 id="writefile-异步写入"><a class="markdownIt-Anchor" href="#writefile-异步写入">#</a> writeFile 异步写入</h3><p><strong>语法</strong>： <code>fs.writeFile(file, data[, options], callback)</code></p><p><strong>参数说明</strong>：</p><ul><li><p>file 文件名</p></li><li><p>data 待写入的数据</p></li><li><p>options 选项设置 <code>（可选）</code></p></li><li><p>callback 写入回调</p></li></ul><p><strong>返回值</strong>： <code>undefined</code></p><p><strong>代码示例</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// require 是 Node.js 环境中的 &#x27;全局&#x27; 变量，用来导入模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 [三人行，必有我师焉。] 写入到当前文件夹下的 [座右铭.txt] 文件中</span></span><br><span class="line">fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;./座右铭.txt&#x27;</span>, <span class="string">&#x27;三人行，必有我师焉。&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 如果写入失败，则回调函数调用时，会传入错误对象，如写入成功，会传入 null</span></span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入成功&#x27;</span>)  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="writefilesync-同步写入"><a class="markdownIt-Anchor" href="#writefilesync-同步写入">#</a> writeFileSync 同步写入</h3><p><strong>语法:</strong> <code>fs.writeFileSync(file, data[, options])</code></p><p>参数与 <code>fs.writeFile</code> 大体一致，只是没有 callback 参数</p><p><strong>返回值：</strong> <code>undefined</code></p><p>代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    fs.<span class="title function_">writeFileSync</span>(<span class="string">&#x27;./座右铭.txt&#x27;</span>, <span class="string">&#x27;三人行，必有我师焉。&#x27;</span>)</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Node.js 中的磁盘操作是由其他 <code>线程</code> 完成的，结果的处理有两种模式:</p><ul><li>同步处理 JavaScript 主线程 <code>会等待</code> 其线程的执行结果，然后再继续执行主线程的代码， <code>效率较低</code></li><li>异步处理 JavaScript 主线程 <code>不会等待</code> 其线程的执行结果，直接执行后续的主线程代码， <code>效率较好</code></li></ul></blockquote><h3 id="appendfile-appendfilesync-追加写入"><a class="markdownIt-Anchor" href="#appendfile-appendfilesync-追加写入">#</a> appendFile /appendFileSync 追加写入</h3><blockquote><p><code>appendFile</code> 作用是在文件尾部追加内容， <code>appendFile</code> 语法与 <code>writeFile</code> 语法完全相同</p></blockquote><p><strong>语法</strong>:</p><p><code>fs.appendFile(file, data[, options], callback)</code></p><p><code>fs.appendFileSync(file, data[, options])</code></p><p><strong>返回值</strong>：二者都为 <code>undefined</code></p><p>实例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">append</span>(<span class="string">&#x27;./座右铭.txt&#x27;</span>, <span class="string">&#x27;则其善者而从之，其不善者而改之。&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;追加成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">appendFileSync</span>(<span class="string">&#x27;./座右铭.txt&#x27;</span>,<span class="string">&#x27;\r\n温故而知新，可以为师矣&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="createwritestream-流式写入"><a class="markdownIt-Anchor" href="#createwritestream-流式写入">#</a> createWriteStream 流式写入</h3><p><strong>语法</strong>： <code>fs.createWriteStream(path[, options])</code></p><p><strong>参数说明</strong>：</p><ul><li><p><code>path</code> 文件路径</p></li><li><p><code>options</code> 选项配置（ <code>可选</code> ）</p></li></ul><p>** 返回值: ** <code>Object</code></p><p>代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ws = fs.<span class="title function_">createWriteStream</span>(<span class="string">&#x27;./观书有感.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入数据到流</span></span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;半亩方塘一鉴开\r\n&#x27;</span>)</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;天光云影共徘徊\r\n&#x27;</span>)</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;问渠那得清如许\r\n&#x27;</span>)</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;为有源头活水来\r\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭写入流，表明已没有数据要被写入可写流</span></span><br><span class="line">ws.<span class="title function_">end</span>()</span><br></pre></td></tr></table></figure><blockquote><p><span style="color:red">程序打开一个文件是需要消耗资源的</span>，流式写入可以减少打开关闭文件的次数。</p><p>流式写入方式适用于 <span style="color:red">大文件写入或者频繁写入</span>的场景， <code>writeFile</code> 适合于 <span style="color:red">写入频率较低的场景</span></p></blockquote><h3 id="写入文件的场景"><a class="markdownIt-Anchor" href="#写入文件的场景">#</a> 写入文件的场景</h3><p><code>文件写入</code> 在计算机中是一个非常常见的操作，下面的场景都用到了文件写入</p><ul><li><p>下载文件</p></li><li><p>安装软件</p></li><li><p>保存程序日志，如 Git</p></li><li><p>编辑器保存文件</p></li><li><p>视频录制</p></li></ul><blockquote><p>当 <span style="color:red">需要持久化保存数据</span> 的时候，应该想到 <code>文件写入</code></p></blockquote><h2 id="文件读取"><a class="markdownIt-Anchor" href="#文件读取">#</a> 文件读取</h2><blockquote><p>文件读取顾名思义，就是通过程序从文件中取出其中的数据，我们可以使用如下几种方式：</p></blockquote><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>readFile</td><td>异步读取</td></tr><tr><td>readFileSync</td><td>同步读取</td></tr><tr><td>createReadStream</td><td>流式读取</td></tr></tbody></table><h3 id="readfile-异步读取"><a class="markdownIt-Anchor" href="#readfile-异步读取">#</a> readFile 异步读取</h3><p><strong>语法</strong>: <code>fs.readFile(path[, options], callback)</code></p><p><strong>参数说明</strong>：</p><ul><li><p>path 文件路径</p></li><li><p>options 选项配置</p></li><li><p>callback 回调函数</p></li></ul><p><strong>返 回 值 ：</strong> <code>undefined</code></p><p>代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 fs 模块</span></span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./座右铭.txt&#x27;</span>, <span class="function">(<span class="params">error,data</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./座右铭.txt&#x27;</span>, <span class="string">&#x27;uft-8&#x27;</span>, <span class="function">(<span class="params">error,data</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="readfilesync-同步读取"><a class="markdownIt-Anchor" href="#readfilesync-同步读取">#</a> readFileSync 同步读取</h3><p><strong>语法：</strong> <code>fs.readFileSync(path[, options])</code></p><p><strong>参数说明：</strong></p><ul><li><p>path 文件路径</p></li><li><p>options 选项配置</p></li></ul><p><strong>返 回 值 ：</strong> <code>string | Buffer</code></p><p>代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./座右铭.txt&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> data = fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./座右铭.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="createreadstream-流式读取"><a class="markdownIt-Anchor" href="#createreadstream-流式读取">#</a> createReadStream 流式读取</h3><p><strong>语法：</strong> <code>fs.createReadStream(path[, options])</code></p><p><strong>参数说明：</strong></p><ul><li><p>path 文件路径</p></li><li><p>options 选项配置（ <code>可选</code> ）</p></li></ul><p><strong>返回值：</strong> <code>Object</code></p><p>代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建读取流对象</span></span><br><span class="line"><span class="keyword">let</span> rs = fs.<span class="title function_">createReadStream</span>(<span class="string">&#x27;./观书有感.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次取出 64k 数据后执行一次 data 回调</span></span><br><span class="line"><span class="comment">// 绑定一个 data 事件  chunk 块儿  大块儿</span></span><br><span class="line">re.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(chunk)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(chunk.<span class="property">length</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取完毕后，执行 end 回调 (可选事件)</span></span><br><span class="line">re.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取完毕&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="读取文件应用场景"><a class="markdownIt-Anchor" href="#读取文件应用场景">#</a> 读取文件应用场景</h3><ul><li><p>电脑开机</p></li><li><p>程序运行</p></li><li><p>编辑器打开文件</p></li><li><p>查看图片</p></li><li><p>播放视频</p></li><li><p>播放音乐</p></li><li><p>Git 查看日志</p></li><li><p>上传文件</p></li><li><p>查看聊天记录</p></li></ul><h2 id="文件移动与重命名"><a class="markdownIt-Anchor" href="#文件移动与重命名">#</a> 文件移动与重命名</h2><blockquote><p>在 Node.js 中，我们可以使用 <code>rename</code> 或 <code>renameSync</code> 来移动或重命名 <code>文件或文件夹</code></p></blockquote><p><strong>语法：</strong></p><p><code>fs.rename(oldPath, newPath, callback)</code></p><p><code>fs.renameSync(oldPath, newPath)</code></p><p><strong>参数说明：</strong></p><ul><li><p>oldPath 文件当前的路径</p></li><li><p>newPath 文件新的路径</p></li><li><p>callback 操作后的回调</p></li></ul><p>代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">rename</span>(<span class="string">&#x27;./观书有感.txt&#x27;</span>, <span class="string">&#x27;./论语/观书有感.txt&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(err) <span class="keyword">throw</span> err</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;移动完成&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">renameSync</span>(<span class="string">&#x27;./座右铭.txt&#x27;</span>, <span class="string">&#x27;./论语/.我的座右铭.txt&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>注</strong>：如果还是移动到当前路径，但是修改了名字，就是重命名了</p><h2 id="文件删除"><a class="markdownIt-Anchor" href="#文件删除">#</a> 文件删除</h2><blockquote><p>在 Node.js 中，我们可以使用 <code>unlink</code> 或 <code>unlinkSync</code> 来删除文件</p></blockquote><p><strong>语法:</strong></p><p><code>fs.unlink(path, callback)</code></p><p><code>fs.unlinkSync(path)</code></p><p><strong>参数说明</strong>：</p><ul><li><p>path 文件路径</p></li><li><p>callback 操作后的回调</p></li></ul><p>代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">unlink</span>(<span class="string">&#x27;./test.txt&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;删除成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">unlinkSync</span>(<span class="string">&#x27;./test2.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 rm 方法  14.4   同步 rmSync</span></span><br><span class="line">fs.<span class="title function_">rm</span>(<span class="string">&#x27;./论语.txt&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;删除失败&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;删除成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="文件夹操作"><a class="markdownIt-Anchor" href="#文件夹操作">#</a> 文件夹操作</h2><blockquote><p>借助 Node.js 的能力，我们可以对文件夹进行 <code>创建</code> 、 <code>读取</code> 、 <code>删除</code> 等操作</p></blockquote><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>mkdir / mkdirSync</td><td>创建文件夹</td></tr><tr><td>readdir / readdirSync</td><td>读取文件夹</td></tr><tr><td>rmdir / rmdirSync</td><td>删除文件夹</td></tr></tbody></table><h3 id="mkdir-创建文件夹"><a class="markdownIt-Anchor" href="#mkdir-创建文件夹">#</a> mkdir 创建文件夹</h3><blockquote><p>在 Node.js 中，我们可以使用 <code>mkdir</code> 或 <code>mkdirSync</code> 来创建文件夹</p></blockquote><p><strong>语法</strong>:</p><p><code>fs.mkdir(path[, options], callback)</code></p><p><code>fs.mkdirSync(path[, options])</code></p><p><strong>参数说明</strong>：</p><ul><li><p>path 文件夹路径</p></li><li><p>options 选项配置（ <code>可选</code> ）</p></li><li><p>callback 操作后的回调</p></li></ul><p>示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步创建文件夹  mk  make  制作   dir  directory  文件夹</span></span><br><span class="line">fs.<span class="title function_">mkdir</span>(<span class="string">&#x27;./page&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;创建成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归异步创建</span></span><br><span class="line">fs.<span class="title function_">mkdir</span>(<span class="string">&#x27;./1/2/3&#x27;</span>, &#123;<span class="attr">recursive</span>: <span class="literal">true</span>&#125;, <span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;递归创建成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归同步创建文件夹</span></span><br><span class="line">fs.<span class="title function_">mkdirSync</span>(<span class="string">&#x27;./x/y/z&#x27;</span>, &#123;<span class="attr">recursive</span>: <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="readdir-读取文件夹"><a class="markdownIt-Anchor" href="#readdir-读取文件夹">#</a> readdir 读取文件夹</h3><blockquote><p>在 Node.js 中，我们可以使用 <code>readdir</code> 或 <code>readdirSync</code> 来读取文件夹</p></blockquote><p><strong>语法：</strong></p><p><code>fs.readdir(path[, options], callback)</code></p><p><code>fs.readdirSync(path[, options])</code></p><p><strong>参数说明：</strong></p><ul><li><p>path 文件夹路径</p></li><li><p>options 选项配置（ <code>可选</code> ）</p></li><li><p>callback 操作后的回调</p></li></ul><p>示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步读取</span></span><br><span class="line">fs.<span class="title function_">readdir</span>(<span class="string">&#x27;./论语&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(err) <span class="keyword">throw</span> err</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 同步读取 </span></span><br><span class="line"><span class="keyword">let</span> data = fs.<span class="title function_">readdirSync</span>(<span class="string">&#x27;./论语&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br></pre></td></tr></table></figure><h3 id="rmdir-删除文件夹"><a class="markdownIt-Anchor" href="#rmdir-删除文件夹">#</a> rmdir 删除文件夹</h3><blockquote><p>在 Node.js 中，我们可以使用 <code>rmdir</code> 或 <code>rmdirSync</code> 来删除文件夹</p></blockquote><p><strong>语法</strong>：</p><p><code>fs.rmdir(path[, options], callback)</code></p><p><code>fs.redirSync(path[, options])</code></p><p><strong>参数说明</strong>：</p><ul><li><p>path 文件夹路径</p></li><li><p>options 选项配置（ 可选 ）</p></li><li><p>callback 操作后的回调</p></li></ul><p>示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步删除文件夹  rm  remove 移除</span></span><br><span class="line">fs.<span class="title function_">rmdir</span>(<span class="string">&#x27;./page&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;删除成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//异步递归删除文件夹  不推荐</span></span><br><span class="line"><span class="comment">//=&gt;DeprecationWarning: In future versions of Node.js, fs.rmdir(path, &#123; recursive: true &#125;) will be removed. Use fs.rm(path, &#123; recursive: true &#125;) instead</span></span><br><span class="line">fs.<span class="title function_">rmdirSync</span>(<span class="string">&#x27;./1&#x27;</span>, &#123;<span class="attr">recursive</span>: <span class="literal">true</span>&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123; </span><br><span class="line">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;递归删除&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//同步递归删除文件夹</span></span><br><span class="line">fs.<span class="title function_">rmdirSync</span>(<span class="string">&#x27;./x&#x27;</span>, &#123;<span class="attr">recursive</span>: <span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建议使用</span></span><br><span class="line">fs.<span class="title function_">rm</span>(<span class="string">&#x27;./a&#x27;</span>, &#123; <span class="attr">recursive</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;删除成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="查看资源状态"><a class="markdownIt-Anchor" href="#查看资源状态">#</a> 查看资源状态</h2><blockquote><p>在 Node.js 中，我们可以使用 <code>stat</code> 或 <code>statSync</code> 来查看资源的详细信息</p></blockquote><p><strong>语法</strong>：</p><p><code>fs.stat(path[, options], callback)</code></p><p><code>fs.statSync(path[, options])</code></p><p><strong>参数说明</strong>：</p><ul><li><p>path 文件夹路径</p></li><li><p>options 选项配置（ 可选 ）</p></li><li><p>callback 操作后的回调</p></li></ul><p>示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步获取状态</span></span><br><span class="line"><span class="comment">// stat  方法  status 缩写 状态</span></span><br><span class="line">fs.<span class="title function_">stat</span>(<span class="string">&#x27;/data.txt&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 同步获取状态</span></span><br><span class="line"><span class="keyword">let</span> data = fs.<span class="title function_">statSync</span>(<span class="string">&#x27;./data.txt&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="./assets/3d5f0b54415a2949c04dcbc49a0452e7ec91899b.png" alt="image-20230321144242912"></p><p><strong>结果值对象结构</strong>：</p><ul><li><p>size 文件体积</p></li><li><p>birthtime 创建时间</p></li><li><p>mtime 最后修改时间</p></li><li><p>isFile 检测是否为文件</p></li><li><p>isDirectory 检测是否为文件夹</p></li><li><p>…</p></li></ul><h2 id="相对路径问题"><a class="markdownIt-Anchor" href="#相对路径问题">#</a> 相对路径问题</h2><p>fs 模块对资源进行操作时，路径的写法有两种：</p><ul><li><p>相对路径</p><ul><li><code>./座右铭.txt</code> 当前目录下的 座右铭.txt</li><li><code>座右铭.txt</code> 等效于上面的写法</li><li><code>../座右铭.txt</code> 当前目录的上一级目录中的 座右铭.txt</li></ul></li><li><p>绝对路径</p><ul><li><code>D:/Program Files</code> windows 系统下的绝对路径</li><li><code>/user/bin</code> Linux 系统下的绝对路径</li></ul></li></ul><blockquote><p>相对路径中所谓的 <code>当前目录</code> ，指的是 <code>命名行的工作目录</code> ，而并非是文件的所在目录</p><p>所以当命名行的工作目录与文件所在目录不一致时，会出现一些 Bug</p></blockquote><h2 id="__dirname"><a class="markdownIt-Anchor" href="#__dirname">#</a> __dirname</h2><p><code>__dirname</code> 与 <code>require</code> 类似，都是 Node.js 环境中的 ‘全局’ 变量</p><p><code>__dirname</code> 保存着 <span style="color:red">当前文件夹所在目录的绝对路径</span>，可以使用 <code>__dirname</code> 与文件名拼接成绝对路径</p><p>代码示例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=&gt;__dirname + &#x27;/data.txt&#x27;  === &#x27;D:\\Desktop\\Node\\code\\03-fs模块/data.txt&#x27;</span></span><br><span class="line"><span class="keyword">let</span> data = fs.<span class="title function_">readFileSync</span>(__dirname + <span class="string">&#x27;/data.txt&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data) </span><br></pre></td></tr></table></figure><blockquote><p>使用 fs 模块的时候，尽量使用 <code>__dirname</code> 路径转换为绝对路径，这样可以避免相对路径产生的 Bug</p></blockquote><h2 id="练习"><a class="markdownIt-Anchor" href="#练习">#</a> 练习</h2><h3 id="编写一个-js-文件实现复制文件的功能"><a class="markdownIt-Anchor" href="#编写一个-js-文件实现复制文件的功能">#</a> 编写一个 JS 文件，实现复制文件的功能</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> *  需求:</span></span><br><span class="line"><span class="comment"> *    复制  资料文件夹下的  [笑看风云.mp4]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 导入 fs 模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="comment">// 方式一  readFile</span></span><br><span class="line"><span class="comment">// 读取文件内容</span></span><br><span class="line"><span class="keyword">let</span> data = fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./资料/笑看风云.mp4&#x27;</span>)</span><br><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line">fs.<span class="title function_">writeFileSync</span>(<span class="string">&#x27;./资料/笑看风云2.mp4&#x27;</span>, data)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二 流式操作</span></span><br><span class="line"><span class="comment">// 创建读取流对象</span></span><br><span class="line"><span class="keyword">const</span> rs = fs.<span class="title function_">createReadStream</span>(<span class="string">&#x27;./资料/笑看风云.mp4&#x27;</span>)</span><br><span class="line"><span class="comment">// 创建一个写入流对象</span></span><br><span class="line"><span class="keyword">const</span> ws = fs.<span class="title function_">createWriteStream</span>(<span class="string">&#x27;./资料/笑看风云3.mp4&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定data事件</span></span><br><span class="line"><span class="comment">// 理想状态下，读取 64k 就写入 64 k，这样消耗的内存最少，实际上读取的速度大于写入的速度</span></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> &#123;</span><br><span class="line">   ws.<span class="title function_">write</span>(chunk)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//  绑定data事件 ==== rs.pipe(ws)</span></span><br></pre></td></tr></table></figure><h3 id="文件重命名"><a class="markdownIt-Anchor" href="#文件重命名">#</a> 文件重命名</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 导入 fs 模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 03-fs模块 文件夹</span></span><br><span class="line"><span class="keyword">const</span> files = fs.<span class="title function_">readdirSync</span>(<span class="string">&#x27;../03-fs模块&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line">files.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 判断</span></span><br><span class="line">  <span class="keyword">let</span> [num, name] = item.<span class="title function_">split</span>(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span> (num &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    num = <span class="string">&#x27;0&#x27;</span> + num</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建新的文件名</span></span><br><span class="line">  <span class="keyword">let</span> newName = num + <span class="string">&#x27;-&#x27;</span> + name</span><br><span class="line">  <span class="comment">// 重命名</span></span><br><span class="line">  fs.<span class="title function_">renameSync</span>(<span class="string">`../03-fs模块/<span class="subst">$&#123;item&#125;</span>`</span>, <span class="string">`../03-fs模块/<span class="subst">$&#123;newName&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="path模块"><a class="markdownIt-Anchor" href="#path模块">#</a> path 模块</h1><blockquote><p><code>path</code> 模块提供了 <code>操作路径</code> 的功能，我们将介绍如下几个较为常用的几个 API (主要用第一个 <code>path.resolve</code> )：</p></blockquote><table><thead><tr><th><strong>API</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>path.resolve</td><td>拼接规范的绝对路径 <code>常用</code></td></tr><tr><td>path.sep</td><td>获取操作系统的路径分隔符</td></tr><tr><td>path.parse</td><td>解析路径并返回对象</td></tr><tr><td>path.basename</td><td>获取路径的基础名称</td></tr><tr><td>path.dirname</td><td>获取路径的目录名</td></tr><tr><td>path.extname</td><td>获得路径的扩展名</td></tr></tbody></table><p>代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 fs 模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="comment">// 导入 path 模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line"><span class="comment">// fs.writeFileSync(__dirname + &#x27;/index.html&#x27;, &#x27;love&#x27;)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(__dirname + <span class="string">&#x27;/index.html&#x27;</span>) <span class="comment">//=&gt;D:\Desktop\Node\code\04-path/index.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// resolve 解决问题  拼接绝对路径</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./index.html&#x27;</span>)) <span class="comment">//=&gt;D:\Desktop\Node\code\04-path\index.html</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;index.html&#x27;</span>)) <span class="comment">//=&gt;D:\Desktop\Node\code\04-path\index.html</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;/index.html&#x27;</span>, <span class="string">&#x27;./test&#x27;</span>)) <span class="comment">//=&gt;D:\index.html\test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sep 获取路径分隔符</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="property">sep</span>) <span class="comment">//=&gt; window \  linux /</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// parse 方法  __filename  &#x27;全局变量&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(__filename) <span class="comment">//=&gt;文件的绝对路径 //=&gt;D:\Desktop\Node\code\04-path\01-path.js</span></span><br><span class="line"><span class="comment">// 解析路径</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;D:\\Desktop\\Node\\code\\04-path\\01-path.js&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">parse</span>(str))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取路径基础名称</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">basename</span>(pathname))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取路径的目录名</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">dirname</span>(pathname))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取路径的拓展名</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">extname</span>(pathname))</span><br></pre></td></tr></table></figure><h1 id="http-协议"><a class="markdownIt-Anchor" href="#http-协议">#</a> HTTP 协议</h1><h2 id="概念-2"><a class="markdownIt-Anchor" href="#概念-2">#</a> 概念</h2><blockquote><p>HTTP（hypertext transport protocol）协议；中文叫 <span style="color:red">超文本传输协议</span></p></blockquote><p>是一种基于 TCP/IP 的应用层通信协议</p><p>这个协议详细规定了 <code>浏览器</code> 和 万维网 <code>服务器</code> 之间互相通信的规则</p><p>协议中主要规定了两个方面的内容:</p><ul><li><p>客户端：用来向服务器发送数据，可以被称之为 <span style="color:red">请求报文</span></p></li><li><p>服务端：向客户端返回数据，可以被称之为 <span style="color:red">响应报文</span></p></li></ul><blockquote><p>报文：可以简单理解为就是一堆字符串</p></blockquote><h2 id="请求报文的组成"><a class="markdownIt-Anchor" href="#请求报文的组成">#</a> 请求报文的组成</h2><ul><li>请求行</li><li>请求头</li><li>空行</li><li>请求体</li></ul><p><img src="https://eucli-1314359160.cos.ap-beijing.myqcloud.com/test/Q$G@" alt="">}4DTBP28G0W`)~NCTJ.png)</p><h2 id="http-的请求行"><a class="markdownIt-Anchor" href="#http-的请求行">#</a> <strong>HTTP</strong> 的请求行</h2><blockquote><p>请求行由三部分组成：请求方法、URL、HTTP 版本号</p></blockquote><ul><li><p>请求方法（get、post、put、delete 等）</p></li><li><p>请求 URL（统一资源定位器），其本身也是一个字符串，定位服务器中的资源</p><p>例如：<a target="_blank" rel="noopener" href="http://www.baidu.com/index.html?a=100&amp;b=200#logo">http://www.baidu.com/index.html?a=100&amp;b=200#logo</a></p><ul><li>http: 协议 (https、ftp、ssh 等)</li><li><a target="_blank" rel="noopener" href="http://www.baidu.com">www.baidu.com</a> 域名</li><li>80 端口号</li><li>/index.html 路径</li><li>a=100&amp;b=200 查询字符串</li><li>#logo 哈希 (锚点链接)</li></ul></li><li><p>HTTP 协议版本号</p></li></ul><h2 id="http-请求头"><a class="markdownIt-Anchor" href="#http-请求头">#</a> HTTP 请求头</h2><p><code>格式：『头名：头值』</code><br>HTTP 请求头提供了关于请求，响应或者其他的发送实体的信息。HTTP 的头信息包括通用头、请求头、响应头和实体头四个部分。每个头域由一个域名，冒号（:）和域值三部分组成。</p><p>常见的请求头有：</p><table><thead><tr><th>请求头</th><th>解释</th></tr></thead><tbody><tr><td>Host</td><td>主机名</td></tr><tr><td>Connection</td><td>连接的设置 keep-alive（保持连接）；close（关闭连接）</td></tr><tr><td>Cache-Control</td><td>缓存控制 max-age = 0 （没有缓存）</td></tr><tr><td>Upgrade-Insecure-Requests</td><td>将网页中的 http 请求转化为 https 请求（很少用）老网站升级</td></tr><tr><td>User-Agent</td><td>用户代理，客户端字符串标识，服务器可以通过这个标识来识别这个请求来自哪个客户端 ，一般在 PC 端和手机端的区分</td></tr><tr><td>Accept</td><td>设置浏览器接收的数据类型</td></tr><tr><td>Accept-Encoding</td><td>设置接收的压缩方式</td></tr><tr><td>Accept-Language</td><td>设置接收的语言 q=0.7 为喜好系数，满分为 1</td></tr><tr><td>Cookie</td><td>后面单独讲</td></tr></tbody></table><h2 id="http-的请求体"><a class="markdownIt-Anchor" href="#http-的请求体">#</a> HTTP 的请求体</h2><p>请求体内容的格式是非常灵活的，</p><p>（可以是空）==&gt; GET 请求，</p><p>（也可以是字符串，还可以是 JSON）===&gt; POST 请求</p><p>例如：</p><ul><li><p>字符串：keywords = 手机 &amp; price=2000</p></li><li keywords:手机,price:2000=""><p>JSON：</p></li></ul><h2 id="响应报文的组成"><a class="markdownIt-Anchor" href="#响应报文的组成">#</a> 响应报文的组成</h2><p><img src="https://eucli-1314359160.cos.ap-beijing.myqcloud.com/test/C~ZJ6K5" alt="">F5BXF@AZ@4_$TBW.png)</p><ul><li><p>响应行: <code>HTTP/1.1 200 OK</code></p><ul><li><p>HTTP/1.1：HTTP 协议版本号</p></li><li><p>200：响应状态码 404 Not Found 500 Internal Server Error</p><p>还有一些状态码，参考：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status</a><br>![](<a target="_blank" rel="noopener" href="https://eucli-1314359160.cos.ap-beijing.myqcloud.com/test/KX~4(TLEGLOCBSB7_A4O6@0.png)">https://eucli-1314359160.cos.ap-beijing.myqcloud.com/test/KX~4(TLEGLOCBSB7_A4O6@0.png)</a></p></li><li><p>OK：响应状态描述<br><img src="https://eucli-1314359160.cos.ap-beijing.myqcloud.com/test/EJ$%7B%7D" alt=""> NA$0F~4VOE1] I83YK.png)</p></li></ul></li></ul><blockquote><p>响应状态码 和 响应字符串 关系是 一一对应 的。</p></blockquote><ul><li><p>响应头</p><ul><li><code>Cache-Control</code> : 缓存控制 private 私有的，只允许客户端缓存数据</li><li><code>Connection</code> : 链接设置</li><li><code>Content-Type:text/html;charset=utf-8</code> : 设置响应体的数据类型以及字符集，响应体为 html，字符集 utf-8</li><li><code>Content-Length</code> : 响应体的长度，单位为字节</li></ul></li><li><p>空行</p></li><li><p>响应体</p><p>响应体内容的类型是非常灵活的，常见的类型有 HTML、CSS、JS、图片、JSON</p></li></ul><h2 id="ip"><a class="markdownIt-Anchor" href="#ip">#</a> IP</h2><ol><li>了解 ip</li></ol><blockquote><p>ip 可以理解成地址，其本身是一个数字标识，由 32 位的二进制数字转十进制转化而来。<br>ip 用来标识网络中的设备，实现设备间通信。任何设备只要接入互联网都会有一个 ip 地址<br><img src="https://eucli-1314359160.cos.ap-beijing.myqcloud.com/test/TT%7B2%5D7%7DJU68OI198%5B6~VW%7BB.png" alt=""></p></blockquote><ol start="2"><li>ip 的分类</li></ol><ul><li>ip 总共只有 32 位，最多能表示 40 多亿个 ip 地址，但全世界有 80 多亿人，每个人又不可能只有一个接入互联网的设备，这就造成了 ip 不够用的情况<br>目前解决 ip 不够用的方法：共享 ip（区域共享、家庭共享）<br><img src="https://eucli-1314359160.cos.ap-beijing.myqcloud.com/test/0UP6%5BDDV7NQV$22SGK%5BW7GM.png" alt=""><br><img src="https://eucli-1314359160.cos.ap-beijing.myqcloud.com/test/_$31T5%256~BE%258MKUJPANRP5.png" alt=""><br><img src="https://eucli-1314359160.cos.ap-beijing.myqcloud.com/test/0E%7BI21N~XU@%5DSE6K%5D1K%60CW8.png" alt=""><br>局域网 ip 是可以被复用的，每个局域网再通过一个公网 ip 就可以实现相互间的通信了<br><img src="https://eucli-1314359160.cos.ap-beijing.myqcloud.com/test/32$TAVS5%5D%5D_8K2OE@ZCRWC9.png" alt=""></li></ul><hr><ul><li>本地回环 ip 地址： <code>127.0.0.1~127.255.255.254</code><br>永远访问本机，用什么设备就会访问这个设备本身</li></ul><p><img src="https://eucli-1314359160.cos.ap-beijing.myqcloud.com/test/JPXVT5LX_983X%5BW3QAOW8D9.png" alt=""></p><h2 id="端口"><a class="markdownIt-Anchor" href="#端口">#</a> 端口</h2><p>端口：应用程序的数字标识。<br><img src="https://eucli-1314359160.cos.ap-beijing.myqcloud.com/test/" alt="">~6SM@{C9](Q3BZ%XL9S_`B.png)</p><blockquote><p>一台现代计算机有 65536 个端口（0~65535）<br>一个应用程序可以使用一个或多个端口</p></blockquote><ul><li>端口的主要作用：<br>实现不同主机应用程序间的通信</li><li>端口场景说明<br><img src="https://eucli-1314359160.cos.ap-beijing.myqcloud.com/test/P2TG7T(WLO2%60G$A2O33E)JT.png" alt=""></li></ul><h2 id="创建-http-服务"><a class="markdownIt-Anchor" href="#创建-http-服务">#</a> 创建 <strong>HTTP</strong> 服务</h2><p>使用 nodejs 创建 HTTP 服务</p><h3 id="操作步骤"><a class="markdownIt-Anchor" href="#操作步骤">#</a> 操作步骤</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 导入 http 模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 创建服务对象 create 创建 server 服务</span></span><br><span class="line"><span class="comment">// request 意为请求. 是对请求报文的封装对象, 通过 request 对象可以`获得请求报文的数据`</span></span><br><span class="line"><span class="comment">// response 意为响应. 是对响应报文的封装对象, 通过 response 对象可以`设置响应报文`</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123; 		</span><br><span class="line">    <span class="comment">// 设置响应体并结束响应</span></span><br><span class="line">    response.<span class="title function_">end</span>(<span class="string">&#x27;Hello HTTP server&#x27;</span>);</span><br><span class="line">&#125;);  <span class="comment">//=&gt;返回结果是一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 监听端口, 启动服务。`listen()`方法传入两个参数：端口号（结合上面端口的介绍）、启动成功后执行的函数体</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">9000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务已经启动, 端口 9000 监听中...&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p><code>http.createServer</code> 里的回调函数的执行时机： <span style="color:red">当接收到 HTTP 请求的时候，就会执行</span><br>使用浏览器访问该 http 服务 (127.0.0.1:9000)，http 服务就会返回响应报文： <code>Hello HTTP server</code><br><img src="https://eucli-1314359160.cos.ap-beijing.myqcloud.com/test/X21IDO~IT%254%7DL$" alt="">`KS()~%1.png)<br>nodejs 应用程序占用了本机的 9000 端口</p></blockquote><h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项">#</a> 注意事项</h3><ol><li><p>命令行 <code>ctrl + c</code> 停止服务</p></li><li><p>当服务启动后，更新代码 <span style="color:red">必须重启服务才能生效</span></p></li><li><p>响应内容中文乱码的解决办法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置响应头</span></span><br><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&#x27;content-type&#x27;</span>,<span class="string">&#x27;text/html;charset=utf-8&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>端口号被占用 (非常常见)</p><p><code>Error: listen EADDRINUSE: address already in use :::9000</code></p><p>1）关闭当前正在运行监听端口的服务 （ <span style="color:red">使用较多</span> ）</p><p>2）修改其他端口号</p></li><li><p><code>HTTP</code> 协议<span style="color:red">默认端口</span>是 <code>80</code> 。 <code>HTTPS</code> 协议的<span style="color:red">默认端口</span>是 <code>443</code> , HTTP 服务开发常用端口有 <code>3000</code> ， <code>8080</code> ， <code>8090</code> ， <code>9000</code> 等</p></li></ol><blockquote><p>如果端口被其他程序占用，可以使用 <span style="color:red">资源监视器</span> 找到占用端口的程序 (开始按钮搜索 “资源监视器”，记住占用端口的 PID)，然后使用 <span style="color:red">任务管理器</span> 关闭对应的程序（根据前面查到的 PID 找）</p></blockquote><h2 id="浏览器查看-http-报文"><a class="markdownIt-Anchor" href="#浏览器查看-http-报文">#</a> 浏览器查看 HTTP 报文</h2><p>点击步骤</p><p><img src="https://eucli-1314359160.cos.ap-beijing.myqcloud.com/test/5e43303dea39359bd3514518f3d5517efac21bd2.jpg" alt=""></p><h3 id="查看请求行与请求头"><a class="markdownIt-Anchor" href="#查看请求行与请求头">#</a> 查看请求行与请求头</h3><p><img src="https://eucli-1314359160.cos.ap-beijing.myqcloud.com/test/e5062ab2d8edc132beddd35d7cd40c83a8b81c87.jpg" alt=""></p><h3 id="查看请求体"><a class="markdownIt-Anchor" href="#查看请求体">#</a> 查看请求体</h3><p><img src="https://eucli-1314359160.cos.ap-beijing.myqcloud.com/test/e421f0e1e84c5ec43bcc56f7856c1f7b623b69a5.jpg" alt=""></p><h3 id="查看-url-查询字符串"><a class="markdownIt-Anchor" href="#查看-url-查询字符串">#</a> 查看 <strong>URL</strong> 查询字符串</h3><p><img src="https://eucli-1314359160.cos.ap-beijing.myqcloud.com/test/9373dc9437fa52b90d195ed8d76f10e346c8e9e3.jpg" alt=""></p><h3 id="查看响应行与响应头"><a class="markdownIt-Anchor" href="#查看响应行与响应头">#</a> 查看响应行与响应头</h3><p><img src="https://eucli-1314359160.cos.ap-beijing.myqcloud.com/test/a553bc93e90d1721bfc27fc960edeeea2eb7ea90.jpg" alt=""></p><h3 id="查看响应体"><a class="markdownIt-Anchor" href="#查看响应体">#</a> 查看响应体</h3><p><img src="https://eucli-1314359160.cos.ap-beijing.myqcloud.com/test/a9440ee4a416d06a8f28be8f524c685ccac4c68d.jpg" alt=""></p><h2 id="获取-http-请求报文"><a class="markdownIt-Anchor" href="#获取-http-请求报文">#</a> 获取 HTTP 请求报文</h2><p>只有通过 <code>请求报文</code> 得到需求，才能根据需求返回正确的 <code>响应报文</code></p><table><thead><tr><th style="text-align:left">含义</th><th style="text-align:left">语法</th><th style="text-align:left">重点掌握</th></tr></thead><tbody><tr><td style="text-align:left">请求方法</td><td style="text-align:left"><code>request.method</code></td><td style="text-align:left">*****</td></tr><tr><td style="text-align:left">请求版本</td><td style="text-align:left">request.httpVersion</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">请求路径</td><td style="text-align:left"><code>request.url</code></td><td style="text-align:left">*****</td></tr><tr><td style="text-align:left">URL 路径</td><td style="text-align:left"><code>require('url').parse(request.url).pathname</code></td><td style="text-align:left">*****</td></tr><tr><td style="text-align:left">URL 查询字符串</td><td style="text-align:left"><code>require('url').parse(request.url, true).query</code></td><td style="text-align:left">*****</td></tr><tr><td style="text-align:left">请求头</td><td style="text-align:left"><code>request.headers</code></td><td style="text-align:left">*****</td></tr><tr><td style="text-align:left">请求体</td><td style="text-align:left">request.on(‘data’, function(chunk){})<br>request.on(‘end’, function(){})</td><td style="text-align:left"></td></tr></tbody></table><ul><li>获取 HTTP 请求报文</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 导入 http 模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建服务对象</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 获取请求的方法</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">method</span>)  <span class="comment">//=&gt;GET</span></span><br><span class="line">  <span class="comment">// 获取请求的 url</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">url</span>)  <span class="comment">// 只包含 url 中的 路径 与查询字符串</span></span><br><span class="line">  <span class="comment">// 获取 http 协议的版本号</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">httpVersion</span>)  <span class="comment">//=&gt; 1.1</span></span><br><span class="line">  <span class="comment">// 获取 http 的请求头</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">headers</span>) <span class="comment">//=&gt;结果是一个对象</span></span><br><span class="line">  response.<span class="title function_">end</span>(<span class="string">&#x27;http&#x27;</span>) <span class="comment">//=&gt;设置响应体</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 监听端口，启动服务</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">9000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务已经启动...&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ol><li><code>request.url</code> 只能获取路径以及查询字符串，无法获取 URL 中的域名以及协议的内容</li><li><code>request.headers</code> 将请求信息转化成一个对象，并将属性名都转化成了『小写』</li><li>关于路径：如果访问网站的时候，只填写了 IP 地址或者是域名信息，此时请求的路径为 <code>/</code></li><li>关于 <code>favicon.ico</code> ：这个请求是属于浏览器自动发送的请求</li></ol><ul><li>提取 http 报文的请求体</li></ul><blockquote><p>注意：get 请求的请求体一般是空的，要发送 post 请求<br>下面这个方法了解即可，后面会介绍更简单的提取报文请求体的方法</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 导入 http 模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建服务对象</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 1. 声明一个变量，用来接收响应结果</span></span><br><span class="line">  <span class="keyword">let</span> body = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="comment">// 2. 绑定 data 事件</span></span><br><span class="line">  request.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> &#123;</span><br><span class="line">    body += chunk</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 3. 绑定 end 事件，请求完后打印body</span></span><br><span class="line">  request.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(body)  <span class="comment">//=&gt;&#x27;username=111&amp;password=111&#x27;</span></span><br><span class="line">  <span class="comment">// 响应</span></span><br><span class="line">  response.<span class="title function_">end</span>(<span class="string">&#x27;Hello Http&#x27;</span>) <span class="comment">//=&gt;设置响应体 </span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 监听端口，启动服务</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">9000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务已经启动...&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>提取 http 报文中 url 的路径 与 查询字符串（<strong>重要</strong>）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 http 模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="comment">// 1. 导入 url 模块</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务对象</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 2. 解析 request.url</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">url</span>)   <span class="comment">//=&gt;/search?keyword=h5</span></span><br><span class="line">  <span class="comment">// 使用 parse 解析 request.url 的内容,parse就是“解析”的意思</span></span><br><span class="line">  <span class="comment">// true 将 query 属性将会设置为一个 对象</span></span><br><span class="line">  <span class="keyword">let</span> res = url.<span class="title function_">parse</span>(request.<span class="property">url</span>, <span class="literal">true</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)  <span class="comment">// 如下图所示，为一个对象</span></span><br><span class="line">  <span class="comment">// 获取路径</span></span><br><span class="line">  <span class="keyword">let</span> pathname = res.<span class="property">pathname</span></span><br><span class="line">  <span class="comment">// 获取查询字符串</span></span><br><span class="line">  <span class="keyword">let</span> keyword = res.<span class="property">query</span>.<span class="property">keyword</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(keyword)   <span class="comment">//=&gt;h5</span></span><br><span class="line">  response.<span class="title function_">end</span>(<span class="string">&#x27;url&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口，启动服务</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">9000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务已经启动...&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://eucli-1314359160.cos.ap-beijing.myqcloud.com/test/3960e1c84da383ba7dda53b627e1dc68384f2e49.png" alt=""></p><ul><li>提取 http 报文中 url 的路径 与 查询字符串 [新]（<strong>重要</strong>）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 http 模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务对象</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 实例化 url 对象</span></span><br><span class="line">  <span class="comment">// let url = new URL(&#x27;/search?a=100&amp;b=200&#x27;,&#x27;http://127.0.0.1:9000&#x27;)</span></span><br><span class="line">  <span class="keyword">let</span> url = <span class="keyword">new</span> <span class="title function_">URL</span>(request.<span class="property">url</span>, <span class="string">&#x27;http://127.0.0.1&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(url)  <span class="comment">//=&gt;如图所示，为一个对象</span></span><br><span class="line">  <span class="comment">// 输出路径</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(url.<span class="property">pathname</span>)  <span class="comment">//=&gt;/search</span></span><br><span class="line">  <span class="comment">// 输出 keyword 查询字符串</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(url.<span class="property">searchParams</span>.<span class="title function_">get</span>(<span class="string">&#x27;a&#x27;</span>))  <span class="comment">//=&gt; 100</span></span><br><span class="line">  response.<span class="title function_">end</span>(<span class="string">&#x27;url new&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口，启动服务</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">9000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务已经启动...&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://eucli-1314359160.cos.ap-beijing.myqcloud.com/test/67ddb914c3ae4e0444a8a1fdab0fa2b58d0e3065.png" alt=""></p><h3 id="练习-2"><a class="markdownIt-Anchor" href="#练习-2">#</a> 练习</h3><p>按照以下要求搭建 HTTP 服务</p><table><thead><tr><th>请求类型 **(<strong>方法</strong>)**</th><th>请求地址</th><th>响应体结果</th></tr></thead><tbody><tr><td>get</td><td>/login</td><td>登录页面</td></tr><tr><td>get</td><td>/reg</td><td>注册页面</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、引入http模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、建立服务</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request,response</span>)=&gt;</span>&#123; </span><br><span class="line">    <span class="keyword">let</span> &#123;url, method&#125; = request; <span class="comment">//对象的解构赋值</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置响应头信息</span></span><br><span class="line">	<span class="comment">//解决中文乱码</span></span><br><span class="line">	response.<span class="title function_">setHeader</span>(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;text/html;charset=utf-8&quot;</span>) </span><br><span class="line">    <span class="keyword">if</span>(url == <span class="string">&quot;/register&quot;</span> &amp;&amp; method == <span class="string">&quot;GET&quot;</span>)&#123;</span><br><span class="line">		response.<span class="title function_">end</span>(<span class="string">&quot;注册页面&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(url==<span class="string">&quot;/login&quot;</span> &amp;&amp; method == <span class="string">&quot;GET&quot;</span>)&#123;</span><br><span class="line">		response.<span class="title function_">end</span>(<span class="string">&quot;登录页面&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		response.<span class="title function_">end</span>(<span class="string">&quot;&lt;h1&gt;404 Not Found&lt;/h1&gt;&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、监听端口</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8000</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务启动中....&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="设置-http-响应报文"><a class="markdownIt-Anchor" href="#设置-http-响应报文">#</a> 设置 <strong>HTTP</strong> 响应报文</h2><table><thead><tr><th>作用</th><th>语法</th></tr></thead><tbody><tr><td>设置响应状态码</td><td>response.statusCode</td></tr><tr><td>设置响应状态描述</td><td>response.statusMessage （ 用的非常少 ）</td></tr><tr><td>设置响应头信息</td><td>response.setHeader (‘头名’, ‘头值’) ( <code>可以自定义</code> )</td></tr><tr><td>设置响应体</td><td>response.write(‘xx’)<br>response.end(‘xxx’)</td></tr></tbody></table><ul><li>设置响应报文</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 设置响应状态码</span></span><br><span class="line">response.<span class="property">statusCode</span> = <span class="number">203</span></span><br><span class="line"><span class="comment">// 2. 响应状态的描述</span></span><br><span class="line">response.<span class="property">statusMessage</span> = <span class="string">&#x27;i love you&#x27;</span></span><br><span class="line"><span class="comment">// 3. 响应头</span></span><br><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&#x27;content-type&#x27;</span>, <span class="string">&#x27;text/html;charset=utf-8&#x27;</span>)</span><br><span class="line"><span class="comment">// 自定义响应头</span></span><br><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&#x27;myHeader&#x27;</span>, <span class="string">&#x27;test test&#x27;</span>)</span><br><span class="line"><span class="comment">// 设置多个同名的响应头</span></span><br><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&#x27;test&#x27;</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br></pre></td></tr></table></figure><ul><li>设置响应报文的响应体</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write 和 end 的两种使用情况：</span></span><br><span class="line"><span class="comment">// 1. write 和 end 的结合使用 响应体相对分散</span></span><br><span class="line">response.<span class="title function_">write</span>(<span class="string">&#x27;xx&#x27;</span>);</span><br><span class="line">response.<span class="title function_">write</span>(<span class="string">&#x27;xx&#x27;</span>);</span><br><span class="line">response.<span class="title function_">write</span>(<span class="string">&#x27;xx&#x27;</span>);</span><br><span class="line">response.<span class="title function_">end</span>(); <span class="comment">//每一个请求，在处理的时候必须要执行 end 方法的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 单独使用 end 方法 响应体相对集中</span></span><br><span class="line">response.<span class="title function_">end</span>(<span class="string">&#x27;xxx&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="练习-3"><a class="markdownIt-Anchor" href="#练习-3">#</a> 练习</h3><p>搭建 HTTP 服务，响应一个 4 行 3 列的表格，并且要求表格有 <code>隔行换色效果</code> ，且 <code>点击</code> 单元格能 <code>高亮显示</code></p><p><strong>方法一</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 http 模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务对象</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;content-type&#x27;</span>, <span class="string">&#x27;text/html;charset=utf-8&#x27;</span>)</span><br><span class="line">  response.<span class="title function_">end</span>(<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">    &lt;html lang=&quot;en&quot;&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;head&gt;</span></span><br><span class="line"><span class="string">      &lt;meta charset=&quot;UTF-8&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;title&gt;Document&lt;/title&gt;</span></span><br><span class="line"><span class="string">      &lt;style&gt;</span></span><br><span class="line"><span class="string">        td &#123;</span></span><br><span class="line"><span class="string">          padding: 20px 40px;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        table tr:nth-child(odd) &#123;</span></span><br><span class="line"><span class="string">          background-color: #aef;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        table tr:nth-child(even) &#123;</span></span><br><span class="line"><span class="string">          background-color: #fcb;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        table,</span></span><br><span class="line"><span class="string">        td &#123;</span></span><br><span class="line"><span class="string">          border-collapse: collapse;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &lt;/style&gt;</span></span><br><span class="line"><span class="string">    &lt;/head&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">      &lt;table border=&quot;1&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;tr&gt;</span></span><br><span class="line"><span class="string">          &lt;td&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="string">          &lt;td&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="string">          &lt;td&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="string">        &lt;/tr&gt;</span></span><br><span class="line"><span class="string">        &lt;tr&gt;</span></span><br><span class="line"><span class="string">          &lt;td&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="string">          &lt;td&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="string">          &lt;td&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="string">        &lt;/tr&gt;</span></span><br><span class="line"><span class="string">        &lt;tr&gt;</span></span><br><span class="line"><span class="string">          &lt;td&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="string">          &lt;td&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="string">          &lt;td&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="string">        &lt;/tr&gt;</span></span><br><span class="line"><span class="string">        &lt;tr&gt;</span></span><br><span class="line"><span class="string">          &lt;td&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="string">          &lt;td&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="string">          &lt;td&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="string">        &lt;/tr&gt;</span></span><br><span class="line"><span class="string">      &lt;/table&gt;</span></span><br><span class="line"><span class="string">      &lt;script&gt;</span></span><br><span class="line"><span class="string">        const tds = document.querySelectorAll(&#x27;td&#x27;)</span></span><br><span class="line"><span class="string">        tds.forEach(item =&gt; &#123;</span></span><br><span class="line"><span class="string">          item.addEventListener(&#x27;click&#x27;, function () &#123;</span></span><br><span class="line"><span class="string">            this.style.backgroundColor = &#x27;#000&#x27;</span></span><br><span class="line"><span class="string">          &#125;)</span></span><br><span class="line"><span class="string">        &#125;)</span></span><br><span class="line"><span class="string">      &lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;/html&gt;</span></span><br><span class="line"><span class="string">  `</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口，启动服务器</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">9000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务器已经启动...&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>方法二</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 http 模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务对象</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;content-type&#x27;</span>, <span class="string">&#x27;text/html;charset=utf-8&#x27;</span>)</span><br><span class="line">  <span class="comment">// 读取文件内容</span></span><br><span class="line">  <span class="keyword">let</span> html = fs.<span class="title function_">readFileSync</span>(__dirname + <span class="string">&#x27;/table.html&#x27;</span>)</span><br><span class="line">  <span class="comment">// end 方法的参数可以是字符串也可以是Buffer</span></span><br><span class="line">  response.<span class="title function_">end</span>(html)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口，启动服务器</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">9000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务器已经启动...&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="网页资源的基本加载过程重要"><a class="markdownIt-Anchor" href="#网页资源的基本加载过程重要">#</a> 网页资源的基本加载过程（<strong>重要</strong>）</h2><p><img src="https://eucli-1314359160.cos.ap-beijing.myqcloud.com/test/929cb3e9fb5f89c7589ee9a7cd93e767ae1a1bc9.jpg" alt=""><br><img src="https://eucli-1314359160.cos.ap-beijing.myqcloud.com/test/01b27104af8ecfe88afc6f70450cc04682d95f31.jpg" alt=""></p><p>网页资源的加载都是循序渐进的，首先获取 HTML 的内容， 然后解析 HTML 在发送其他资源的请求，如 CSS，Javascript，图片等。<span style="color:red">理解了这个内容对于后续的学习与成长有非常大的帮助</span></p><h2 id="静态资源服务"><a class="markdownIt-Anchor" href="#静态资源服务">#</a> 静态资源服务</h2><p><code>静态资源</code> 是指 <span style="color:red">内容长时间不发生改变的资源</span> ，例如图片，视频，CSS 文件，JS 文件，HTML 文件，字体文件等</p><p><code>动态资源</code> 是指 <span style="color:red">内容经常更新的资源</span> ，例如百度首页，网易首页，京东搜索列表页面等</p><h3 id="http响应练习"><a class="markdownIt-Anchor" href="#http响应练习">#</a> http 响应练习</h3><p>创建一个 http 服务，端口为 9000，满足下列需求<br>GET /index.html 响应 page/index.html 文件内容<br>GET /css/app.css 响应 page/css/app.css 文件内容<br>GET /images/logo.png 响应 page/images/logo.png 文件内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 http 模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务对象</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;content-type&#x27;</span>, <span class="string">&#x27;text/html;charset=utf-8&#x27;</span>)</span><br><span class="line">  <span class="comment">//获取请求url路径</span></span><br><span class="line">  <span class="keyword">let</span> &#123;pathname&#125; = <span class="keyword">new</span> <span class="title function_">URL</span>(request.<span class="property">url</span>,<span class="string">&#x27;http://127.0.0.1&#x27;</span>)</span><br><span class="line">  <span class="comment">//拼接文件路径</span></span><br><span class="line">  <span class="keyword">let</span> filePath = __dirname + <span class="string">&#x27;/page&#x27;</span> + pathname</span><br><span class="line">  <span class="comment">//读取文件fs异步api</span></span><br><span class="line">  fs.<span class="title function_">readFile</span>(filePath,<span class="function">(<span class="params">err,data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">      response.<span class="property">statusCode</span> = <span class="number">500</span>;</span><br><span class="line">      response.<span class="title function_">end</span>(<span class="string">&#x27;文件读取失败~&#x27;</span>)</span><br><span class="line">      retuen</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//响应文件内容</span></span><br><span class="line">    response.<span class="title function_">end</span>(data)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口，启动服务器</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">9000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务器已经启动...&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="网站根目录或静态资源目录"><a class="markdownIt-Anchor" href="#网站根目录或静态资源目录">#</a> 网站根目录或静态资源目录</h3><p>HTTP 服务在哪个文件夹中寻找静态资源，那个文件夹就是 <span style="color:red">静态资源目录</span> ，也称之为 <span style="color:red">网站根目录</span></p><blockquote><p>思考：vscode 中使用 live-server 访问 HTML 时， 它启动的服务中网站根目录是谁？</p><ul><li>该文件的所处的文件夹</li></ul></blockquote><h3 id="网页中的-url"><a class="markdownIt-Anchor" href="#网页中的-url">#</a> 网页中的 <strong>URL</strong></h3><p>网页中的 URL 主要分为两大类： <code>相对路径</code> 与 <code>绝对路径</code></p><h4 id="绝对路径"><a class="markdownIt-Anchor" href="#绝对路径">#</a> 绝对路径</h4><p>绝对路径可靠性强，而且相对容易理解，在项目中运用较多</p><table><thead><tr><th>形式</th><th>特点</th></tr></thead><tbody><tr><td><a target="_blank" rel="noopener" href="http://atguigu.com/web">http://atguigu.com/w eb</a></td><td>直接向目标资源发送请求，容易理解。网站的外链会用到此形式</td></tr><tr><td><a target="_blank" rel="noopener" href="//atguigu.com/web">//atguigu.com/web</a></td><td>与页面 URL 的协议拼接形成完整 URL 再发送请求。大型网站用的比较多</td></tr><tr><td>/web</td><td>与页面 URL 的协议、主机名、端口拼接形成完整 URL 再发送请求。中小型网站</td></tr></tbody></table><h4 id="相对路径"><a class="markdownIt-Anchor" href="#相对路径">#</a> 相对路径</h4><p>相对路径在发送请求时，需要与当前页面 URL 路径进行 <code>计算</code> ，得到完整 URL 后，再发送请求，学习阶段用的较多</p><p>例如当前网页 url 为 <a target="_blank" rel="noopener" href="http://www.atguigu.com/course/h5.html">http://www.atguigu.com/course/h5.html</a></p><table><thead><tr><th>形式</th><th>最终的 <strong>URL</strong></th></tr></thead><tbody><tr><td>./css/app.css</td><td><a target="_blank" rel="noopener" href="http://www.atguigu.com/course/css/app.css">http://www.atguigu.com/course/css/app.css</a></td></tr><tr><td>js/app.js</td><td><a target="_blank" rel="noopener" href="http://www.atguigu.com/course/js/app.js">http://www.atguigu.com/course/js/app.js</a></td></tr><tr><td>…/img/logo.png</td><td><a target="_blank" rel="noopener" href="http://www.atguigu.com/img/logo.png">http://www.atguigu.com/img/logo.png</a></td></tr><tr><td>…/…/mp4/show.mp4</td><td><a target="_blank" rel="noopener" href="http://www.atguigu.com/mp4/show.mp4">http://www.atguigu.com/mp4/show.mp4</a></td></tr></tbody></table><h4 id="网页中使用-url-的场景小结"><a class="markdownIt-Anchor" href="#网页中使用-url-的场景小结">#</a> 网页中使用 <strong>URL</strong> 的场景小结</h4><p>包括但不限于如下场景：</p><ul><li>a 标签 href</li><li>link 标签 href</li><li>script 标签 src</li><li>img 标签 src</li><li>video audio 标签 src</li><li>form 中的 action</li><li>AJAX 请求中的 URL</li></ul><h3 id="设置资源类型mime类型"><a class="markdownIt-Anchor" href="#设置资源类型mime类型">#</a> 设置资源类型（<strong>mime</strong> 类型）</h3><p><code>媒体类型</code> （通常称为 Multipurpose Internet Mail Extensions 或 MIME 类型 ）是一种标准，用来表示文档、文件或字节流的性质和格式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mime 类型结构： [<span class="built_in">type</span>]/[subType]</span><br><span class="line">[主类型]/[辅类型]</span><br><span class="line">例如： text/html text/css image/jpeg image/png application/json</span><br></pre></td></tr></table></figure><p>HTTP 服务可以设置响应头 Content-Type 来表明响应体的 MIME 类型，浏览器会根据该类型决定如何处理资源</p><p>下面是常见文件对应的 mime 类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">html</span>: <span class="string">&#x27;text/html&#x27;</span>,</span><br><span class="line"><span class="attr">css</span>: <span class="string">&#x27;text/css&#x27;</span>,</span><br><span class="line"><span class="attr">js</span>: <span class="string">&#x27;text/javascript&#x27;</span>,</span><br><span class="line"><span class="attr">png</span>: <span class="string">&#x27;image/png&#x27;</span>,</span><br><span class="line"><span class="attr">jpg</span>: <span class="string">&#x27;image/jpeg&#x27;</span>, </span><br><span class="line"><span class="attr">gif</span>: <span class="string">&#x27;image/gif&#x27;</span>,</span><br><span class="line"><span class="attr">mp4</span>: <span class="string">&#x27;video/mp4&#x27;</span>,</span><br><span class="line"><span class="attr">mp3</span>: <span class="string">&#x27;audio/mpeg&#x27;</span>,</span><br><span class="line"><span class="attr">json</span>: <span class="string">&#x27;application/json&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>对于未知的资源类型，可以选择 <code>application/octet-stream</code> 类型，浏览器在遇到该类型的响应时，会对响应体内容进行独立存储，也就是我们常见的 <code>下载</code> 效果</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>).<span class="title function_">createServer</span>(<span class="function">(<span class="params">request,response</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="comment">//获取请求的方法已经路径</span></span><br><span class="line">	<span class="keyword">let</span> &#123;url,method&#125; = request;</span><br><span class="line">	<span class="comment">//判断请求方式以及请求路径</span></span><br><span class="line">	<span class="keyword">if</span>(method == <span class="string">&quot;GET&quot;</span> &amp;&amp; url == <span class="string">&quot;/index.html&quot;</span>)&#123;</span><br><span class="line">		<span class="comment">//需要响应文件中的内容</span></span><br><span class="line">		<span class="keyword">let</span> data = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>).<span class="title function_">readFileSync</span>( dirname + <span class="string">&#x27;/index.html&#x27;</span>);</span><br><span class="line">         response.<span class="title function_">end</span>(data);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(method == <span class="string">&quot;GET&quot;</span> &amp;&amp; url == <span class="string">&quot;/css/app.css&quot;</span>)&#123;</span><br><span class="line">		<span class="comment">//需要响应文件中的内容</span></span><br><span class="line">		<span class="keyword">let</span> data = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>).<span class="title function_">readFileSync</span>( dirname + <span class="string">&#x27;/public/css/app.css&#x27;</span>);</span><br><span class="line">		response.<span class="title function_">end</span>(data);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(method == <span class="string">&quot;GET&quot;</span> &amp;&amp; url == <span class="string">&quot;/js/app.js&quot;</span>)&#123;</span><br><span class="line">		<span class="comment">//需要响应文件中的内容</span></span><br><span class="line">		<span class="keyword">let</span> data = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>).<span class="title function_">readFileSync</span>( dirname + <span class="string">&#x27;/public/js/app.js&#x27;</span>);</span><br><span class="line">         response.<span class="title function_">end</span>(data);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">//404响应</span></span><br><span class="line">         response.<span class="property">statusCode</span> = <span class="number">404</span>;</span><br><span class="line">		response.<span class="title function_">end</span>(<span class="string">&quot;&lt;h1&gt;404 Not Found&lt;/h1&gt;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">80</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;80端口正在启动中....&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>很明显上面的代码，当只要有一个请求路径就需要进行判断，显然这种方式不够完美，那么我们需要封装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>).<span class="title function_">createServer</span>(<span class="function">(<span class="params">request,response</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="comment">//获取请求的方法已经路径</span></span><br><span class="line">	<span class="keyword">let</span> &#123;url,method&#125; = request;</span><br><span class="line">	<span class="comment">//文件夹路径  根路径</span></span><br><span class="line">	<span class="keyword">let</span> rootDir = dirname + <span class="string">&#x27;/public&#x27;</span>;</span><br><span class="line">	<span class="comment">//拼接文件路径</span></span><br><span class="line">	<span class="keyword">let</span> filePath = rootDir + url;</span><br><span class="line">	<span class="comment">//读取文件内容</span></span><br><span class="line">    fs.<span class="title function_">readFile</span>(filePath,<span class="function">(<span class="params">err,data</span>)=&gt;</span>&#123;</span><br><span class="line">		<span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">			<span class="comment">//如果出现错误，响应404状态码</span></span><br><span class="line">            response.<span class="property">statusCode</span> = <span class="number">404</span>; </span><br><span class="line">            response.<span class="title function_">end</span>(<span class="string">&#x27;&lt;h1&gt;404 Not Found&lt;/h1&gt;&#x27;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//响应文件内容</span></span><br><span class="line">            response.<span class="title function_">end</span>(data);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">80</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;80端口正在启动中....&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="get-和-post-请求场景小结"><a class="markdownIt-Anchor" href="#get-和-post-请求场景小结">#</a> GET <strong>和</strong> POST <strong>请求场景小结</strong></h3><p>GET 请求的情况：</p><ul><li>在地址栏直接输入 url 访问</li><li>点击 a 链接</li><li>link 标签引入 css</li><li>script 标签引入 js</li><li>img 标签引入图片</li><li>form 标签中的 method 为 get （不区分大小写）</li><li>ajax 中的 get 请求</li></ul><p>POST 请求的情况：</p><ul><li><p>form 标签中的 method 为 post（不区分大小写）</p></li><li><p>AJAX 的 post 请求</p></li></ul><h2 id="get和post请求的区别"><a class="markdownIt-Anchor" href="#get和post请求的区别">#</a> <strong>GET</strong> 和<strong> POST</strong> 请求的区别</h2><p><code>GET</code> 和 <code>POST</code> 是 HTTP 协议请求的两种方式。</p><ul><li><code>GET</code> 主要用来获取数据， <code>POST</code> 主要用来提交数据</li><li><code>GET</code> 带参数请求是将参数缀到 URL 之后，在地址栏中输入 url 访问网站就是 GET 请求， <code>POST</code> 带参数请求是将参数放到请求体中</li><li><code>POST</code> 请求相对 <code>GET</code> 安全一些，因为在浏览器中参数会暴露在地址栏</li><li><code>GET</code> 请求大小有限制，一般为 2K，而 POST 请求则没有</li></ul></div></article><div class="toc-container"><div id="toc" class="toc-article"><strong class="toc-title">目录</strong><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#buffer%E7%BC%93%E5%86%B2%E5%99%A8"><span class="toc-text">Buffer（缓冲器）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-text">特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-text">使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-buffer"><span class="toc-text">创建 Buffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#buffer-%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BD%AC%E5%8C%96"><span class="toc-text">Buffer 与字符串的转化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#buffer-%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-text">Buffer 的读写</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fs-%E6%A8%A1%E5%9D%97fs-api"><span class="toc-text">fs 模块（fs API）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5"><span class="toc-text">文件写入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#writefile-%E5%BC%82%E6%AD%A5%E5%86%99%E5%85%A5"><span class="toc-text">writeFile 异步写入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#writefilesync-%E5%90%8C%E6%AD%A5%E5%86%99%E5%85%A5"><span class="toc-text">writeFileSync 同步写入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#appendfile-appendfilesync-%E8%BF%BD%E5%8A%A0%E5%86%99%E5%85%A5"><span class="toc-text">appendFile &#x2F;appendFileSync 追加写入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#createwritestream-%E6%B5%81%E5%BC%8F%E5%86%99%E5%85%A5"><span class="toc-text">createWriteStream 流式写入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-text">写入文件的场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96"><span class="toc-text">文件读取</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#readfile-%E5%BC%82%E6%AD%A5%E8%AF%BB%E5%8F%96"><span class="toc-text">readFile 异步读取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#readfilesync-%E5%90%8C%E6%AD%A5%E8%AF%BB%E5%8F%96"><span class="toc-text">readFileSync 同步读取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#createreadstream-%E6%B5%81%E5%BC%8F%E8%AF%BB%E5%8F%96"><span class="toc-text">createReadStream 流式读取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">读取文件应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%A7%BB%E5%8A%A8%E4%B8%8E%E9%87%8D%E5%91%BD%E5%90%8D"><span class="toc-text">文件移动与重命名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4"><span class="toc-text">文件删除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%A4%B9%E6%93%8D%E4%BD%9C"><span class="toc-text">文件夹操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mkdir-%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-text">mkdir 创建文件夹</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#readdir-%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-text">readdir 读取文件夹</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rmdir-%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-text">rmdir 删除文件夹</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%B5%84%E6%BA%90%E7%8A%B6%E6%80%81"><span class="toc-text">查看资源状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="toc-text">相对路径问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#__dirname"><span class="toc-text">__dirname</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-text">练习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA-js-%E6%96%87%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-text">编写一个 JS 文件，实现复制文件的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8D"><span class="toc-text">文件重命名</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#path%E6%A8%A1%E5%9D%97"><span class="toc-text">path 模块</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#http-%E5%8D%8F%E8%AE%AE"><span class="toc-text">HTTP 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-text">请求报文的组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http-%E7%9A%84%E8%AF%B7%E6%B1%82%E8%A1%8C"><span class="toc-text">HTTP 的请求行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http-%E8%AF%B7%E6%B1%82%E5%A4%B4"><span class="toc-text">HTTP 请求头</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http-%E7%9A%84%E8%AF%B7%E6%B1%82%E4%BD%93"><span class="toc-text">HTTP 的请求体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-text">响应报文的组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ip"><span class="toc-text">IP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3"><span class="toc-text">端口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-http-%E6%9C%8D%E5%8A%A1"><span class="toc-text">创建 HTTP 服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4"><span class="toc-text">操作步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9F%A5%E7%9C%8B-http-%E6%8A%A5%E6%96%87"><span class="toc-text">浏览器查看 HTTP 报文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%AF%B7%E6%B1%82%E8%A1%8C%E4%B8%8E%E8%AF%B7%E6%B1%82%E5%A4%B4"><span class="toc-text">查看请求行与请求头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%AF%B7%E6%B1%82%E4%BD%93"><span class="toc-text">查看请求体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B-url-%E6%9F%A5%E8%AF%A2%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">查看 URL 查询字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%93%8D%E5%BA%94%E8%A1%8C%E4%B8%8E%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="toc-text">查看响应行与响应头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%93%8D%E5%BA%94%E4%BD%93"><span class="toc-text">查看响应体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-http-%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87"><span class="toc-text">获取 HTTP 请求报文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-2"><span class="toc-text">练习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE-http-%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87"><span class="toc-text">设置 HTTP 响应报文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-3"><span class="toc-text">练习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E9%A1%B5%E8%B5%84%E6%BA%90%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E9%87%8D%E8%A6%81"><span class="toc-text">网页资源的基本加载过程（重要）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1"><span class="toc-text">静态资源服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#http%E5%93%8D%E5%BA%94%E7%BB%83%E4%B9%A0"><span class="toc-text">http 响应练习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%AB%99%E6%A0%B9%E7%9B%AE%E5%BD%95%E6%88%96%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%9B%AE%E5%BD%95"><span class="toc-text">网站根目录或静态资源目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E9%A1%B5%E4%B8%AD%E7%9A%84-url"><span class="toc-text">网页中的 URL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="toc-text">绝对路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="toc-text">相对路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E9%A1%B5%E4%B8%AD%E4%BD%BF%E7%94%A8-url-%E7%9A%84%E5%9C%BA%E6%99%AF%E5%B0%8F%E7%BB%93"><span class="toc-text">网页中使用 URL 的场景小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8Bmime%E7%B1%BB%E5%9E%8B"><span class="toc-text">设置资源类型（mime 类型）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get-%E5%92%8C-post-%E8%AF%B7%E6%B1%82%E5%9C%BA%E6%99%AF%E5%B0%8F%E7%BB%93"><span class="toc-text">GET 和 POST 请求场景小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get%E5%92%8Cpost%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">GET 和 POST 请求的区别</span></a></li></ol></li></ol></div></div></div><div class="copyright"><span>本作品采用</span> <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a> <span>进行许可。 转载时请注明原文链接。</span></div><div class="share" style="width:100%"></div><div class="post-nav"><div class="post-nav-item post-nav-next"><span>〈 </span><a href="/2023/05/31/Nginx/" rel="next" title="Nginx学习">Nginx学习</a></div><div class="post-nav-item post-nav-prev"><a href="/2023/07/05/%E5%BC%82%E6%AD%A5async%E3%80%81await/" rel="prev" title="异步async、await">异步async、await </a><span>〉</span></div></div></div></div><footer class="footer text-center"><div id="bottom-inner"><a class="bottom-item" href="https://eucli.top">首页</a> | <a class="bottom-item" href="https://0xff000000.com" target="_blank">主站</a> | <a class="bottom-item" href="https://github.com/monokuma3121" target="_blank">GitHub</a> | <a class="bottom-item" href="https://hexo.io" target="_blank">Powered by hexo</a> | <a class="bottom-item" href="https://github.com/KevinOfNeu/hexo-theme-xoxo" target="_blank">Theme xoxo</a></div></footer><script>!function(e,t,n){function o(){cancelAnimationFrame(d),d=requestAnimationFrame(function e(){var n=t.body.scrollTop||t.documentElement.scrollTop;n>0?(t.body.scrollTop=t.documentElement.scrollTop=n-50,d=requestAnimationFrame(e)):cancelAnimationFrame(d)})}function a(){c(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}"),r(),i(),m()}function i(){for(var e=0;e<u.length;e++)u[e].alpha<=0?(t.body.removeChild(u[e].el),u.splice(e,1)):(u[e].y--,u[e].scale+=.004,u[e].alpha-=.013,u[e].el.style.cssText="left:"+u[e].x+"px;top:"+u[e].y+"px;opacity:"+u[e].alpha+";transform:scale("+u[e].scale+","+u[e].scale+") rotate(45deg);background:"+u[e].color);requestAnimationFrame(i)}function r(){var n="function"==typeof e.onclick&&e.onclick,a=t.getElementById("logo");a&&(a.onclick=function(e){o(),n&&n(),l(e)})}function l(e){var n=t.createElement("div");n.className="heart",u.push({el:n,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(n)}function c(e){var n=t.createElement("style");n.type="text/css";try{n.appendChild(t.createTextNode(e))}catch(o){n.styleSheet.cssText=e}t.getElementsByTagName("head")[0].appendChild(n)}function s(){return"#F44336"}function m(){var e=t.getElementById("menu-main-post");if(e){var n=t.getElementById("toc");n?e.onclick=function(){n&&("block"==n.style.display?n.style.display="none":n.style.display="block")}:e.style.display="none"}}var d=null,u=[];e.requestAnimationFrame=function(){return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)}}(),a()}(window,document)</script></body></html><!-- rebuild by hrmmi -->