{
    "version": "https://jsonfeed.org/version/1",
    "title": "Eucliの小窝 • All posts by \"异步\" tag",
    "description": null,
    "home_page_url": "https://eucli.top",
    "items": [
        {
            "id": "https://eucli.top/2023/11/05/%E5%BC%82%E6%AD%A5async%E3%80%81await/",
            "url": "https://eucli.top/2023/11/05/%E5%BC%82%E6%AD%A5async%E3%80%81await/",
            "title": "异步编程",
            "date_published": "2023-11-05T13:45:48.000Z",
            "content_html": "<h1 id=\"js异步编程\"><a class=\"anchor\" href=\"#js异步编程\">#</a> JS 异步编程</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0FkdmFuY2VkLUZyb250ZW5kL0RhaWx5LUludGVydmlldy1RdWVzdGlvbi9pc3N1ZXMvNw==\">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7</span><br />\n 讲的非常好</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ldWNsaS0xMzE0MzU5MTYwLmNvcy5hcC1iZWlqaW5nLm15cWNsb3VkLmNvbS90ZXN0L2ltYWdlLTIwMjMxMDI5MDk0MTMzNDY5LnBuZw==\">https://eucli-1314359160.cos.ap-beijing.myqcloud.com/test/image-20231029094133469.png</span>&quot; alt=&quot;image-20231029094133469&quot; style=&quot;zoom:80%;&quot; /&gt;</p>\n<h2 id=\"eventloop\"><a class=\"anchor\" href=\"#eventloop\">#</a> EventLoop</h2>\n<p>JavaScript 是单线程的，包含了同步任务与异步任务，同步任务直接在<strong>调用栈</strong> (主线程) 中执行，异步任务会放入<strong>任务队列</strong> (TaskQueue) 中，等待同步任务全部执行完毕再取出来，所以如果异步之中仍有异步任务，在调用栈中执行时会继续放入任务队列中，这就是 JS 的事件循环机制 (EventLoop)。</p>\n<h2 id=\"宏任务与微任务\"><a class=\"anchor\" href=\"#宏任务与微任务\">#</a> 宏任务与微任务</h2>\n<p>异步任务队列实际上分为两种，分别是宏任务队列与微任务队列，<strong>在当前循环中会优先执行微任务，当微任务队列被清空后才会执行宏任务队列。</strong></p>\n<p>微任务实际上是宏任务的其中一个步骤。微任务是 JS 级别的，宏任务是宿主级别的，是包含关系，不是先后关系。</p>\n<h3 id=\"微任务micro-task\"><a class=\"anchor\" href=\"#微任务micro-task\">#</a> 微任务（micro task）：</h3>\n<ul>\n<li>\n<p>promise <code>.then</code> / <code>.catch</code> / <code>.finally</code></p>\n</li>\n<li>\n<p><code>process.nextTick</code></p>\n</li>\n<li>\n<p><code>MutationObserver</code></p>\n</li>\n<li>\n<p><code>async/await</code> : 本质上还是基于 <code>Promise</code>  的一些封装，而 <code>Promise</code>  是属于微任务的一种。所以在使用 <code>await</code>  关键字与 <code>Promise.then</code>  效果类似。</p>\n<blockquote>\n<p><strong>async 函数在 await 之前的代码都是同步执行的，可以理解为 await 之前的代码属于 <code>new Promise</code>  时传入的代码，await 之后的所有代码都是在 <code>Promise.then</code>  中的回调</strong></p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"宏任务macro-task\"><a class=\"anchor\" href=\"#宏任务macro-task\">#</a> 宏任务（macro task）:</h3>\n<ul>\n<li>\n<p>script（整体代码）</p>\n</li>\n<li>\n<p>定时器系列： <code>setTimeout</code> 、 <code>setInterval</code> 、 <code>setImmediate</code></p>\n</li>\n<li>\n<p><code>I/O</code> ：这种比较耗性能的操作浏览器会交给单独的线程去办，得到结果后再通知回来</p>\n</li>\n<li>\n<p><code>requestAnimationFrame</code></p>\n</li>\n</ul>\n<blockquote>\n<p>tips:UI 渲染不是宏任务，而是和微任务平行的一个操作步骤</p>\n</blockquote>\n<h3 id=\"执行顺序\"><a class=\"anchor\" href=\"#执行顺序\">#</a> 执行顺序：</h3>\n<p><strong> <code>同步任务 &gt; 微任务 &gt; requestAnimationFrame &gt; DOM渲染 &gt; 宏任务</code> </strong></p>\n<p>构造函数是同步任务</p>\n<h3 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结：</h3>\n<ol>\n<li>先执行上下文栈的 <code>同步任务</code> ；</li>\n<li>看一下微任务队列有没有需要执行的微任务，按照队列 <code>先进先出</code> 的原则，** <code>一次执行完所有</code>  ** 微任务队列任务；</li>\n<li>执行宏任务队列，<strong> <code>一次执行一个</code> </strong>，每执行完一个都会<strong>检测微任务是否为空</strong>；</li>\n<li>不为空则先执行微任务</li>\n<li>为空再执行下一个宏任务；</li>\n</ol>\n<p><img data-src=\"https://gitee.com/eucli312/img/raw/master/1699173401134-2023-11-5.png\" alt=\"1699173401134-2023-11-5.png\" /></p>\n<p><img data-src=\"https://gitee.com/eucli312/img/raw/master/1699174167689-2023-11-5.png\" alt=\"1699174167689-2023-11-5.png\" /></p>\n<h3 id=\"mutationobserver是一个内建对象它观察-dom-元素并在检测到更改时触发回调\"><a class=\"anchor\" href=\"#mutationobserver是一个内建对象它观察-dom-元素并在检测到更改时触发回调\">#</a> MutationObserver：是一个内建对象，它观察 DOM 元素，并在检测到更改时触发回调</h3>\n<h3 id=\"requestanimationframe\"><a class=\"anchor\" href=\"#requestanimationframe\">#</a> RequestAnimationFrame</h3>\n<ul>\n<li>仅对浏览器生效，回调属于高优先级任务</li>\n<li>会将每一帧中所有 DOM 操作集中一次渲染（所以性能较好）</li>\n<li>回流重绘的时间会跟随刷新频率动态改变，不能主动控制（由于是帧操作，必须递归调用）</li>\n<li>因为是异步任务，在调用后实际还可以取消</li>\n<li>浏览器页面不是激活状态下（或离开标签页），会自动暂停执行</li>\n<li>根据以上特性该方法常用于处理帧动画的操作，性能优于 setInterval</li>\n</ul>\n<h3 id=\"requestidlecallback\"><a class=\"anchor\" href=\"#requestidlecallback\">#</a> RequestIdleCallback</h3>\n<p>该回调函数是低优先级的任务，仅在浏览器空闲时期被调用（目前仍处于实验功能阶段，在微前端中常有应用）</p>\n<h3 id=\"callback\"><a class=\"anchor\" href=\"#callback\">#</a> Callback</h3>\n<p>容易造成回调地狱，不能  <code>try...catch</code>  捕获，不能  <code>return</code></p>\n<h3 id=\"promise\"><a class=\"anchor\" href=\"#promise\">#</a> Promise</h3>\n<p>也会造成回调地狱，但优化了 callback 方式的回调地狱问题，而  <code>async</code> 、 <code>await</code> （ES7）才真正解决了异步回调的问题。</p>\n<h4 id=\"面试高频\"><a class=\"anchor\" href=\"#面试高频\">#</a> <strong>面试高频：</strong></h4>\n<ul>\n<li>\n<p><code>Promise.all</code> ：将一个包含 Promise 实例的数组传入，数组内所有 Promise 实例执行完毕时，该方法会返回结果数组。</p>\n</li>\n<li>\n<p><code>Promise.race</code> ：返回的是最快成功回调的一个结果。</p>\n</li>\n<li>\n<p>实现  <code>Promise.all</code>  的思路：返回一个 promise 对象，方法中设有变量 count、results，循环执行每个 promise，then 回调中 count++，当 count === promises.length 时 resolve (results)</p>\n</li>\n</ul>\n<p>b 站讲解：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVdQNHkxODdUdS8/c3BtX2lkX2Zyb209MzMzLjMzNy5zZWFyY2gtY2FyZC5hbGwuY2xpY2smYW1wO3ZkX3NvdXJjZT1mZjI0Nzc3MmE2MmVlOWMzYjJlZDI3ZmE1ZTRhOTFlMg==\">https://www.bilibili.com/video/BV1WP4y187Tu/?spm_id_from=333.337.search-card.all.click&amp;vd_source=ff247772a62ee9c3b2ed27fa5e4a91e2</span></p>\n<h1 id=\"异步\"><a class=\"anchor\" href=\"#异步\">#</a> 异步</h1>\n<p>js 中异步有两种方式实现：</p>\n<ol>\n<li>回调函数，如 setTimeOut。但是会回调地狱</li>\n<li>Promise。“承诺”：承诺会在未来的某个时刻返回数据。链式调用，避免代码的层层嵌套</li>\n</ol>\n<h1 id=\"asyncawait-是什么\"><a class=\"anchor\" href=\"#asyncawait-是什么\">#</a> async/await 是什么</h1>\n<p>async/await 是 ES2017 (ES8) 提出的基于 Promise 的解决异步的最终方案，是一个语法糖。<br />\nasync 是 “异步” 的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。</p>\n<p>一个问题：await 只能出现在 async 函数中，那这个 async 函数应该怎么调用？如果需要通过 await 来调用一个 async 函数，那这个调用的外面必须得再包一个 async 函数，然后…… 进入死循环，永无出头之日……<br />\nasync 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，我们当然应该用原来的方式：then () 链来处理这个 Promise 对象</p>\n<h2 id=\"async\"><a class=\"anchor\" href=\"#async\">#</a> async</h2>\n<p>async 是一个加在函数前的修饰符，被 async 定义的函数会默认返回一个 Promise 对象 resolve 的值。因此对 async 函数可以直接 then，返回值就是 then 方法传入的函数。</p>\n<h2 id=\"await\"><a class=\"anchor\" href=\"#await\">#</a> await</h2>\n<p>await 也是一个修饰符，只能放在 async 定义的函数内。可以理解为<strong>等待</strong>。可以不再使用 then 直接使用 await</p>\n<ul>\n<li>\n<p>await 到底在等啥？<br />\n一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。<br />\n因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值 —— 这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。</p>\n</li>\n<li>\n<p>await 等到了要等的，然后呢？<br />\nawait 等到了它要等的东西，一个 Promise 对象，或者其它值，然后呢？我不得不先说，await 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西。</p>\n</li>\n</ul>\n<ol>\n<li>如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。</li>\n<li>如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。\n<blockquote>\n<p>看到上面的阻塞一词，心慌了吧…… 放心，这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。</p>\n</blockquote>\n</li>\n</ol>\n<p>——————————————————<br />\n 使用 async 和 await 可以让我们写出更清晰、更容易理解的异步代码，有了它们之后，我们几乎不再需要使用底层的 Promise 对象，包括调用它的 then (),catch () 函数等等</p>\n",
            "tags": [
                "异步"
            ]
        }
    ]
}